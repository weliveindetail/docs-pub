

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>1   TableGen Programmer’s Reference &#8212; LLVM 12 documentation</title>
    <link rel="stylesheet" href="../_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="TableGen Fundamentals" href="../TableGenFundamentals.html" />
    <link rel="prev" title="1   TableGen Backend Developer’s Guide" href="BackGuide.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="../index.html">
    <img src="../_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../TableGenFundamentals.html" title="TableGen Fundamentals"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="BackGuide.html" title="1   TableGen Backend Developer’s Guide"
             accesskey="P">previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" accesskey="U">TableGen Overview</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/GettingStartedTutorials.html">Getting Started/Tutorials</a></li>
    <li><a href="https://llvm.org/docs/UserGuides.html">User Guides</a></li>
    <li><a href="https://llvm.org/docs/Reference.html">Reference</a></li>
</ul>

<h3>Getting Involved</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/Contributing.html">Contributing to LLVM</a></li>
    <li><a href="https://llvm.org/docs/HowToSubmitABug.html">Submitting Bug Reports</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#irc">IRC</a></li>
    <li><a href="https://llvm.org/docs/GettingInvolved.html#meetups-and-social-events">Meetups and Social Events</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://llvm.org/docs/FAQ.html">FAQ</a></li>
    <li><a href="https://llvm.org/docs/Lexicon.html">Glossary</a></li>
    <li><a href="https://llvm.org/pubs">Publications</a></li>
    <li><a href="https://github.com/llvm/llvm-project//">Github Repository</a></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/TableGen/ProgRef.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tablegen-programmer-s-reference">
<h1>1&nbsp;&nbsp;&nbsp;TableGen Programmer’s Reference<a class="headerlink" href="#tablegen-programmer-s-reference" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="id1">1.1&nbsp;&nbsp;&nbsp;Introduction</a><ul class="auto-toc">
<li><a class="reference internal" href="#concepts" id="id2">1.1.1&nbsp;&nbsp;&nbsp;Concepts</a></li>
</ul>
</li>
<li><a class="reference internal" href="#source-files" id="id3">1.2&nbsp;&nbsp;&nbsp;Source Files</a></li>
<li><a class="reference internal" href="#lexical-analysis" id="id4">1.3&nbsp;&nbsp;&nbsp;Lexical Analysis</a><ul class="auto-toc">
<li><a class="reference internal" href="#literals" id="id5">1.3.1&nbsp;&nbsp;&nbsp;Literals</a></li>
<li><a class="reference internal" href="#identifiers" id="id6">1.3.2&nbsp;&nbsp;&nbsp;Identifiers</a></li>
<li><a class="reference internal" href="#bang-operators" id="id7">1.3.3&nbsp;&nbsp;&nbsp;Bang operators</a></li>
<li><a class="reference internal" href="#include-files" id="id8">1.3.4&nbsp;&nbsp;&nbsp;Include files</a></li>
</ul>
</li>
<li><a class="reference internal" href="#types" id="id9">1.4&nbsp;&nbsp;&nbsp;Types</a></li>
<li><a class="reference internal" href="#values-and-expressions" id="id10">1.5&nbsp;&nbsp;&nbsp;Values and Expressions</a><ul class="auto-toc">
<li><a class="reference internal" href="#simple-values" id="id11">1.5.1&nbsp;&nbsp;&nbsp;Simple values</a></li>
<li><a class="reference internal" href="#suffixed-values" id="id12">1.5.2&nbsp;&nbsp;&nbsp;Suffixed values</a></li>
<li><a class="reference internal" href="#the-paste-operator" id="id13">1.5.3&nbsp;&nbsp;&nbsp;The paste operator</a></li>
</ul>
</li>
<li><a class="reference internal" href="#statements" id="id14">1.6&nbsp;&nbsp;&nbsp;Statements</a><ul class="auto-toc">
<li><a class="reference internal" href="#class-define-an-abstract-record-class" id="id15">1.6.1&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">class</span></code> — define an abstract record class</a><ul class="auto-toc">
<li><a class="reference internal" href="#record-bodies" id="id16">1.6.1.1&nbsp;&nbsp;&nbsp;Record Bodies</a></li>
</ul>
</li>
<li><a class="reference internal" href="#def-define-a-concrete-record" id="id17">1.6.2&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">def</span></code> — define a concrete record</a></li>
<li><a class="reference internal" href="#examples-classes-and-records" id="id18">1.6.3&nbsp;&nbsp;&nbsp;Examples: classes and records</a></li>
<li><a class="reference internal" href="#let-override-fields-in-classes-or-records" id="id19">1.6.4&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">let</span></code> — override fields in classes or records</a></li>
<li><a class="reference internal" href="#multiclass-define-multiple-records" id="id20">1.6.5&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">multiclass</span></code> — define multiple records</a></li>
<li><a class="reference internal" href="#defm-invoke-multiclasses-to-define-multiple-records" id="id21">1.6.6&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">defm</span></code> — invoke multiclasses to define multiple records</a></li>
<li><a class="reference internal" href="#examples-multiclasses-and-defms" id="id22">1.6.7&nbsp;&nbsp;&nbsp;Examples: multiclasses and defms</a></li>
<li><a class="reference internal" href="#defset-create-a-definition-set" id="id23">1.6.8&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">defset</span></code> — create a definition set</a></li>
<li><a class="reference internal" href="#defvar-define-a-variable" id="id24">1.6.9&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">defvar</span></code> — define a variable</a></li>
<li><a class="reference internal" href="#foreach-iterate-over-a-sequence-of-statements" id="id25">1.6.10&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">foreach</span></code> — iterate over a sequence of statements</a></li>
<li><a class="reference internal" href="#if-select-statements-based-on-a-test" id="id26">1.6.11&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">if</span></code> — select statements based on a test</a></li>
</ul>
</li>
<li><a class="reference internal" href="#additional-details" id="id27">1.7&nbsp;&nbsp;&nbsp;Additional Details</a><ul class="auto-toc">
<li><a class="reference internal" href="#directed-acyclic-graphs-dags" id="id28">1.7.1&nbsp;&nbsp;&nbsp;Directed acyclic graphs (DAGs)</a></li>
<li><a class="reference internal" href="#defvar-in-a-record-body" id="id29">1.7.2&nbsp;&nbsp;&nbsp;Defvar in a record body</a></li>
<li><a class="reference internal" href="#how-records-are-built" id="id30">1.7.3&nbsp;&nbsp;&nbsp;How records are built</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-classes-as-subroutines" id="id31">1.8&nbsp;&nbsp;&nbsp;Using Classes as Subroutines</a></li>
<li><a class="reference internal" href="#preprocessing-facilities" id="id32">1.9&nbsp;&nbsp;&nbsp;Preprocessing Facilities</a></li>
<li><a class="reference internal" href="#appendix-a-bang-operators" id="id33">1.10&nbsp;&nbsp;&nbsp;Appendix A: Bang Operators</a></li>
<li><a class="reference internal" href="#appendix-b-paste-operator-examples" id="id34">1.11&nbsp;&nbsp;&nbsp;Appendix B: Paste Operator Examples</a></li>
<li><a class="reference internal" href="#appendix-c-sample-record" id="id35">1.12&nbsp;&nbsp;&nbsp;Appendix C: Sample Record</a></li>
</ul>
</div>
<div class="toctree-wrapper compound">
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id1">1.1&nbsp;&nbsp;&nbsp;Introduction</a><a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>The purpose of TableGen is to generate complex output files based on
information from source files that are significantly easier to code than the
output files would be, and also easier to maintain and modify over time. The
information is coded in a declarative style involving classes and records,
which are then processed by TableGen. The internalized records are passed on
to various backends, which extract information from a subset of the records
and generate one or more output files. These output files are typically
<code class="docutils literal notranslate"><span class="pre">.inc</span></code> files for C++, but may be any type of file that the backend
developer needs.</p>
<p>This document describes the LLVM TableGen facility in detail. It is intended
for the programmer who is using TableGen to produce code for a project. If
you are looking for a simple overview, check out the <a class="reference internal" href="index.html"><span class="doc">TableGen Overview</span></a>.  The various <code class="docutils literal notranslate"><span class="pre">xxx-tblgen</span></code> commands used to invoke TableGen are
described in <a class="reference internal" href="../CommandGuide/tblgen.html"><span class="doc">xxx-tblgen: Target Description to C++ Code</span></a>.</p>
<p>An example of a backend is <code class="docutils literal notranslate"><span class="pre">RegisterInfo</span></code>, which generates the register
file information for a particular target machine, for use by the LLVM
target-independent code generator. See <a class="reference internal" href="BackEnds.html"><span class="doc">TableGen Backends</span></a>
for a description of the LLVM TableGen backends, and <a class="reference internal" href="BackGuide.html"><span class="doc">TableGen
Backend Developer’s Guide</span></a> for a guide to writing a new
backend.</p>
<p>Here are a few of the things backends can do.</p>
<ul class="simple">
<li>Generate the register file information for a particular target machine.</li>
<li>Generate the instruction definitions for a target.</li>
<li>Generate the patterns that the code generator uses to match instructions
to intermediate representation (IR) nodes.</li>
<li>Generate semantic attribute identifiers for Clang.</li>
<li>Generate abstract syntax tree (AST) declaration node definitions for Clang.</li>
<li>Generate AST statement node definitions for Clang.</li>
</ul>
<div class="section" id="concepts">
<h3><a class="toc-backref" href="#id2">1.1.1&nbsp;&nbsp;&nbsp;Concepts</a><a class="headerlink" href="#concepts" title="Permalink to this headline">¶</a></h3>
<p>TableGen source files contain two primary items: <em>abstract records</em> and
<em>concrete records</em>. In this and other TableGen documents, abstract records
are called <em>classes.</em> (These classes are different from C++ classes and do
not map onto them.) In addition, concrete records are usually just called
records, although sometimes the term <em>record</em> refers to both classes and
concrete records. The distinction should be clear in context.</p>
<p>Classes and concrete records have a unique <em>name</em>, either chosen by
the programmer or generated by TableGen. Associated with that name
is a list of <em>fields</em> with values and an optional list of <em>superclasses</em>
(sometimes called base or parent classes). The fields are the primary data that
backends will process. Note that TableGen assigns no meanings to fields; the
meanings are entirely up to the backends and the programs that incorporate
the output of those backends.</p>
<p>A backend processes some subset of the concrete records built by the
TableGen parser and emits the output files. These files are usually C++
<code class="docutils literal notranslate"><span class="pre">.inc</span></code> files that are included by the programs that require the data in
those records. However, a backend can produce any type of output files. For
example, it could produce a data file containing messages tagged with
identifiers and substitution parameters. In a complex use case such as the
LLVM code generator, there can be many concrete records and some of them can
have an unexpectedly large number of fields, resulting in large output files.</p>
<p>In order to reduce the complexity of TableGen files, classes are used to
abstract out groups of record fields. For example, a few classes may
abstract the concept of a machine register file, while other classes may
abstract the instruction formats, and still others may abstract the
individual instructions. TableGen allows an arbitrary hierarchy of classes,
so that the abstract classes for two concepts can share a third superclass that
abstracts common “sub-concepts” from the two original concepts.</p>
<p>In order to make classes more useful, a concrete record (or another class)
can request a class as a superclass and pass <em>template arguments</em> to it.
These template arguments can be used in the fields of the superclass to
initialize them in a custom manner. That is, record or class <code class="docutils literal notranslate"><span class="pre">A</span></code> can
request superclass <code class="docutils literal notranslate"><span class="pre">S</span></code> with one set of template arguments, while record or class
<code class="docutils literal notranslate"><span class="pre">B</span></code> can request <code class="docutils literal notranslate"><span class="pre">S</span></code> with a different set of arguments. Without template
arguments, many more classes would be required, one for each combination of
the template arguments.</p>
<p>Both classes and concrete records can include fields that are uninitialized.
The uninitialized “value” is represented by a question mark (<code class="docutils literal notranslate"><span class="pre">?</span></code>). Classes
often have uninitialized fields that are expected to be filled in when those
classes are inherited by concrete records. Even so, some fields of concrete
records may remain uninitialized.</p>
<p>TableGen provides <em>multiclasses</em> to collect a group of record definitions in
one place. A multiclass is a sort of macro that can be “invoked” to define
multiple concrete records all at once. A multiclass can inherit from other
multiclasses, which means that the multiclass inherits all the definitions
from its parent multiclasses.</p>
<p><a class="reference internal" href="#appendix-c-sample-record">Appendix C: Sample Record</a> illustrates a complex record in the Intel X86
target and the simple way in which it is defined.</p>
</div>
</div>
<div class="section" id="source-files">
<h2><a class="toc-backref" href="#id3">1.2&nbsp;&nbsp;&nbsp;Source Files</a><a class="headerlink" href="#source-files" title="Permalink to this headline">¶</a></h2>
<p>TableGen source files are plain ASCII text files. The files can contain
statements, comments, and blank lines (see <a class="reference internal" href="#lexical-analysis">Lexical Analysis</a>). The standard file
extension for TableGen files is <code class="docutils literal notranslate"><span class="pre">.td</span></code>.</p>
<p>TableGen files can grow quite large, so there is an include mechanism that
allows one file to include the content of another file (see <a class="reference internal" href="#include-files">Include
Files</a>). This allows large files to be broken up into smaller ones, and
also provides a simple library mechanism where multiple source files can
include the same library file.</p>
<p>TableGen supports a simple preprocessor that can be used to conditionalize
portions of <code class="docutils literal notranslate"><span class="pre">.td</span></code> files. See <a class="reference internal" href="#preprocessing-facilities">Preprocessing Facilities</a> for more
information.</p>
</div>
<div class="section" id="lexical-analysis">
<h2><a class="toc-backref" href="#id4">1.3&nbsp;&nbsp;&nbsp;Lexical Analysis</a><a class="headerlink" href="#lexical-analysis" title="Permalink to this headline">¶</a></h2>
<p>The lexical and syntax notation used here is intended to imitate
<a class="reference external" href="http://docs.python.org/py3k/reference/introduction.html#notation">Python’s</a> notation. In particular, for lexical definitions, the productions
operate at the character level and there is no implied whitespace between
elements. The syntax definitions operate at the token level, so there is
implied whitespace between tokens.</p>
<p>TableGen supports BCPL-style comments (<code class="docutils literal notranslate"><span class="pre">//</span> <span class="pre">...</span></code>) and nestable C-style
comments (<code class="docutils literal notranslate"><span class="pre">/*</span> <span class="pre">...</span> <span class="pre">*/</span></code>).
TableGen also provides simple <a class="reference internal" href="#preprocessing-facilities">Preprocessing Facilities</a>.</p>
<p>Formfeed characters may be used freely in files to produce page breaks when
the file is printed for review.</p>
<p>The following are the basic punctuation tokens:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>- + [ ] { } ( ) &lt; &gt; : ; . ... = ? #
</pre></div>
</div>
<div class="section" id="literals">
<h3><a class="toc-backref" href="#id5">1.3.1&nbsp;&nbsp;&nbsp;Literals</a><a class="headerlink" href="#literals" title="Permalink to this headline">¶</a></h3>
<p>Numeric literals take one of the following forms:</p>
<pre>
<strong id="grammar-token-tokinteger">TokInteger    </strong> ::=  <a class="reference internal" href="#grammar-token-decimalinteger"><code class="xref docutils literal notranslate"><span class="pre">DecimalInteger</span></code></a> | <a class="reference internal" href="#grammar-token-hexinteger"><code class="xref docutils literal notranslate"><span class="pre">HexInteger</span></code></a> | <a class="reference internal" href="#grammar-token-bininteger"><code class="xref docutils literal notranslate"><span class="pre">BinInteger</span></code></a>
<strong id="grammar-token-decimalinteger">DecimalInteger</strong> ::=  [&quot;+&quot; | &quot;-&quot;] (&quot;0&quot;...&quot;9&quot;)+
<strong id="grammar-token-hexinteger">HexInteger    </strong> ::=  &quot;0x&quot; (&quot;0&quot;...&quot;9&quot; | &quot;a&quot;...&quot;f&quot; | &quot;A&quot;...&quot;F&quot;)+
<strong id="grammar-token-bininteger">BinInteger    </strong> ::=  &quot;0b&quot; (&quot;0&quot; | &quot;1&quot;)+
</pre>
<p>Observe that the <a class="reference internal" href="#grammar-token-decimalinteger"><code class="xref std std-token docutils literal notranslate"><span class="pre">DecimalInteger</span></code></a> token includes the optional <code class="docutils literal notranslate"><span class="pre">+</span></code>
or <code class="docutils literal notranslate"><span class="pre">-</span></code> sign, unlike most languages where the sign would be treated as a
unary operator.</p>
<p>TableGen has two kinds of string literals:</p>
<pre>
<strong id="grammar-token-tokstring">TokString      </strong> ::=  '&quot;' (non-'&quot;' characters and escapes) '&quot;'
<strong id="grammar-token-tokcodefragment">TokCodeFragment</strong> ::=  &quot;[{&quot; (shortest text not containing &quot;}]&quot;) &quot;}]&quot;
</pre>
<p>A <a class="reference internal" href="#grammar-token-tokcodefragment"><code class="xref std std-token docutils literal notranslate"><span class="pre">TokCodeFragment</span></code></a> is nothing more than a multi-line string literal
delimited by <code class="docutils literal notranslate"><span class="pre">[{</span></code> and <code class="docutils literal notranslate"><span class="pre">}]</span></code>. It can break across lines.</p>
<p>The current implementation accepts the following escape sequences:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>\\ \<span class="s1">&#39; </span><span class="se">\&quot;</span><span class="s1"> </span><span class="se">\t</span><span class="s1"> </span><span class="se">\n</span>
</pre></div>
</div>
</div>
<div class="section" id="identifiers">
<h3><a class="toc-backref" href="#id6">1.3.2&nbsp;&nbsp;&nbsp;Identifiers</a><a class="headerlink" href="#identifiers" title="Permalink to this headline">¶</a></h3>
<p>TableGen has name- and identifier-like tokens, which are case-sensitive.</p>
<pre>
<strong id="grammar-token-ualpha">ualpha       </strong> ::=  &quot;a&quot;...&quot;z&quot; | &quot;A&quot;...&quot;Z&quot; | &quot;_&quot;
<strong id="grammar-token-tokidentifier">TokIdentifier</strong> ::=  (&quot;0&quot;...&quot;9&quot;)* <a class="reference internal" href="#grammar-token-ualpha"><code class="xref docutils literal notranslate"><span class="pre">ualpha</span></code></a> (<a class="reference internal" href="#grammar-token-ualpha"><code class="xref docutils literal notranslate"><span class="pre">ualpha</span></code></a> | &quot;0&quot;...&quot;9&quot;)*
<strong id="grammar-token-tokvarname">TokVarName   </strong> ::=  &quot;$&quot; <a class="reference internal" href="#grammar-token-ualpha"><code class="xref docutils literal notranslate"><span class="pre">ualpha</span></code></a> (<a class="reference internal" href="#grammar-token-ualpha"><code class="xref docutils literal notranslate"><span class="pre">ualpha</span></code></a> |  &quot;0&quot;...&quot;9&quot;)*
</pre>
<p>Note that, unlike most languages, TableGen allows <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> to
begin with an integer. In case of ambiguity, a token is interpreted as a
numeric literal rather than an identifier.</p>
<p>TableGen has the following reserved words, which cannot be used as
identifiers:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">bit</span>        <span class="n">bits</span>          <span class="k">class</span>         <span class="nc">code</span>          <span class="n">dag</span>
<span class="k">def</span>        <span class="nf">else</span>          <span class="n">foreach</span>       <span class="n">defm</span>          <span class="n">defset</span>
<span class="n">defvar</span>     <span class="n">field</span>         <span class="k">if</span>            <span class="ow">in</span>            <span class="n">include</span>
<span class="nb">int</span>        <span class="n">let</span>           <span class="nb">list</span>          <span class="n">multiclass</span>    <span class="n">string</span>
<span class="n">then</span>
</pre></div>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">field</span></code> reserved word is deprecated.</p>
</div>
</div>
<div class="section" id="bang-operators">
<h3><a class="toc-backref" href="#id7">1.3.3&nbsp;&nbsp;&nbsp;Bang operators</a><a class="headerlink" href="#bang-operators" title="Permalink to this headline">¶</a></h3>
<p>TableGen provides “bang operators” that have a wide variety of uses:</p>
<pre>
<strong id="grammar-token-bangoperator">BangOperator</strong> ::=  one of
                  !add        !and         !cast        !con         !dag
                  !empty      !eq          !foldl       !foreach     !ge
                  !getdagop   !gt          !head        !if          !isa
                  !le         !listconcat  !listsplat   !lt          !mul
                  !ne         !not         !or          !setdagop    !shl
                  !size       !sra         !srl         !strconcat   !sub
                  !subst      !tail        !xor
</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">!cond</span></code> operator has a slightly different
syntax compared to other bang operators, so it is defined separately:</p>
<pre>
<strong id="grammar-token-condoperator">CondOperator</strong> ::=  !cond
</pre>
<p>See <a class="reference internal" href="#appendix-a-bang-operators">Appendix A: Bang Operators</a> for a description of each bang operator.</p>
</div>
<div class="section" id="include-files">
<h3><a class="toc-backref" href="#id8">1.3.4&nbsp;&nbsp;&nbsp;Include files</a><a class="headerlink" href="#include-files" title="Permalink to this headline">¶</a></h3>
<p>TableGen has an include mechanism. The content of the included file
lexically replaces the <code class="docutils literal notranslate"><span class="pre">include</span></code> directive and is then parsed as if it was
originally in the main file.</p>
<pre>
<strong id="grammar-token-includedirective">IncludeDirective</strong> ::=  &quot;include&quot; <a class="reference internal" href="#grammar-token-tokstring"><code class="xref docutils literal notranslate"><span class="pre">TokString</span></code></a>
</pre>
<p>Portions of the main file and included files can be conditionalized using
preprocessor directives.</p>
<pre>
<strong id="grammar-token-preprocessordirective">PreprocessorDirective</strong> ::=  &quot;#define&quot; | &quot;#ifdef&quot; | &quot;#ifndef&quot;
</pre>
</div>
</div>
<div class="section" id="types">
<h2><a class="toc-backref" href="#id9">1.4&nbsp;&nbsp;&nbsp;Types</a><a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h2>
<p>The TableGen language is statically typed, using a simple but complete type
system. Types are used to check for errors, to perform implicit conversions,
and to help interface designers constrain the allowed input. Every value is
required to have an associated type.</p>
<p>TableGen supports a mixture of low-level types (e.g., <code class="docutils literal notranslate"><span class="pre">bit</span></code>) and
high-level types (e.g., <code class="docutils literal notranslate"><span class="pre">dag</span></code>). This flexibility allows you to describe a
wide range of records conveniently and compactly.</p>
<pre>
<strong id="grammar-token-type">Type   </strong> ::=  &quot;bit&quot; | &quot;int&quot; | &quot;string&quot; | &quot;code&quot; | &quot;dag&quot;
            | &quot;bits&quot; &quot;&lt;&quot; <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a> &quot;&gt;&quot;
            | &quot;list&quot; &quot;&lt;&quot; <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">Type</span></code></a> &quot;&gt;&quot;
            | <a class="reference internal" href="#grammar-token-classid"><code class="xref docutils literal notranslate"><span class="pre">ClassID</span></code></a>
<strong id="grammar-token-classid">ClassID</strong> ::=  <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a>
</pre>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">bit</span></code></dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">bit</span></code> is a boolean value that can be 0 or 1.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">int</span></code></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">int</span></code> type represents a simple 64-bit integer value, such as 5 or
-42.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">string</span></code></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">string</span></code> type represents an ordered sequence of characters of arbitrary
length.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">code</span></code></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">code</span></code> type represents a code fragment. The values are the same as
those for the <code class="docutils literal notranslate"><span class="pre">string</span></code> type; the <code class="docutils literal notranslate"><span class="pre">code</span></code> type is provided just to indicate
the programmer’s intention.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">bits&lt;</span></code><em>n</em><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></dt>
<dd>The <code class="docutils literal notranslate"><span class="pre">bits</span></code> type is a fixed-sized integer of arbitrary length <em>n</em> that
is treated as separate bits. These bits can be accessed individually.
A field of this type is useful for representing an instruction operation
code, register number, or address mode/register/displacement.  The bits of
the field can be set individually or as subfields. For example, in an
instruction address, the addressing mode, base register number, and
displacement can be set separately.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">list&lt;</span></code><em>type</em><code class="docutils literal notranslate"><span class="pre">&gt;</span></code></dt>
<dd>This type represents a list whose elements are of the <em>type</em> specified in
angle brackets. The element type is arbitrary; it can even be another
list type. List elements are indexed from 0.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">dag</span></code></dt>
<dd>This type represents a nestable directed acyclic graph (DAG) of nodes.
Each node has an <em>operator</em> and zero or more <em>arguments</em> (or <em>operands</em>).
An argument can be
another <code class="docutils literal notranslate"><span class="pre">dag</span></code> object, allowing an arbitrary tree of nodes and edges.
As an example, DAGs are used to represent code patterns for use by
the code generator instruction selection algorithms. See <a class="reference internal" href="#directed-acyclic-graphs-dags">Directed
acyclic graphs (DAGs)</a> for more details;</dd>
<dt><a class="reference internal" href="#grammar-token-classid"><code class="xref std std-token docutils literal notranslate"><span class="pre">ClassID</span></code></a></dt>
<dd>Specifying a class name in a type context indicates
that the type of the defined value must
be a subclass of the specified class.  This is useful in conjunction with
the <code class="docutils literal notranslate"><span class="pre">list</span></code> type; for example, to constrain the elements of the list to a
common base class (e.g., a <code class="docutils literal notranslate"><span class="pre">list&lt;Register&gt;</span></code> can only contain definitions
derived from the <code class="docutils literal notranslate"><span class="pre">Register</span></code> class).
The <a class="reference internal" href="#grammar-token-classid"><code class="xref std std-token docutils literal notranslate"><span class="pre">ClassID</span></code></a> must name a class that has been previously
declared or defined.</dd>
</dl>
</div>
<div class="section" id="values-and-expressions">
<h2><a class="toc-backref" href="#id10">1.5&nbsp;&nbsp;&nbsp;Values and Expressions</a><a class="headerlink" href="#values-and-expressions" title="Permalink to this headline">¶</a></h2>
<p>There are many contexts in TableGen statements where a value is required. A
common example is in the definition of a record, where each field is
specified by a name and an optional value. TableGen allows for a reasonable
number of different forms when building up value expressions. These forms
allow the TableGen file to be written in a syntax that is natural for the
application.</p>
<p>Note that all of the values have rules for converting them from one type to
another. For example, these rules allow you to assign a value like <code class="docutils literal notranslate"><span class="pre">7</span></code>
to an entity of type <code class="docutils literal notranslate"><span class="pre">bits&lt;4&gt;</span></code>.</p>
<pre>
<strong id="grammar-token-value">Value      </strong> ::=  <a class="reference internal" href="#grammar-token-simplevalue"><code class="xref docutils literal notranslate"><span class="pre">SimpleValue</span></code></a> <a class="reference internal" href="#grammar-token-valuesuffix"><code class="xref docutils literal notranslate"><span class="pre">ValueSuffix</span></code></a>*
                | <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> &quot;#&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a>
<strong id="grammar-token-valuesuffix">ValueSuffix</strong> ::=  &quot;{&quot; <a class="reference internal" href="#grammar-token-rangelist"><code class="xref docutils literal notranslate"><span class="pre">RangeList</span></code></a> &quot;}&quot;
                | &quot;[&quot; <a class="reference internal" href="#grammar-token-rangelist"><code class="xref docutils literal notranslate"><span class="pre">RangeList</span></code></a> &quot;]&quot;
                | &quot;.&quot; <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a>
<strong id="grammar-token-rangelist">RangeList  </strong> ::=  <a class="reference internal" href="#grammar-token-rangepiece"><code class="xref docutils literal notranslate"><span class="pre">RangePiece</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-rangepiece"><code class="xref docutils literal notranslate"><span class="pre">RangePiece</span></code></a>)*
<strong id="grammar-token-rangepiece">RangePiece </strong> ::=  <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a>
                | <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a> &quot;...&quot; <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a>
                | <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a> &quot;-&quot; <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a>
                | <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a> <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a>
</pre>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The peculiar last form of <a class="reference internal" href="#grammar-token-rangepiece"><code class="xref std std-token docutils literal notranslate"><span class="pre">RangePiece</span></code></a> is due to the fact that the
“<code class="docutils literal notranslate"><span class="pre">-</span></code>” is included in the <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref std std-token docutils literal notranslate"><span class="pre">TokInteger</span></code></a>, hence <code class="docutils literal notranslate"><span class="pre">1-5</span></code> gets lexed as
two consecutive tokens, with values <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">-5</span></code>, instead of “1”, “-“,
and “5”. The use of hyphen as the range punctuation is deprecated.</p>
</div>
<div class="section" id="simple-values">
<h3><a class="toc-backref" href="#id11">1.5.1&nbsp;&nbsp;&nbsp;Simple values</a><a class="headerlink" href="#simple-values" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#grammar-token-simplevalue"><code class="xref std std-token docutils literal notranslate"><span class="pre">SimpleValue</span></code></a> has a number of forms.</p>
<pre>
<strong id="grammar-token-simplevalue">SimpleValue</strong> ::=  <a class="reference internal" href="#grammar-token-tokinteger"><code class="xref docutils literal notranslate"><span class="pre">TokInteger</span></code></a> | <a class="reference internal" href="#grammar-token-tokstring"><code class="xref docutils literal notranslate"><span class="pre">TokString</span></code></a>+ | <a class="reference internal" href="#grammar-token-tokcodefragment"><code class="xref docutils literal notranslate"><span class="pre">TokCodeFragment</span></code></a>
</pre>
<p>A value can be an integer literal, a string literal, or a code fragment
literal. Multiple adjacent string literals are concatenated as in C/C++; the
simple value is the concatenation of the strings. Code fragments become
strings and then are indistinguishable from them.</p>
<pre>
<strong id="grammar-token-simplevalue2">SimpleValue2</strong> ::=  &quot;?&quot;
</pre>
<p>A question mark represents an uninitialized value.</p>
<pre>
<strong id="grammar-token-simplevalue3">SimpleValue3</strong> ::=  &quot;{&quot; [<a class="reference internal" href="#grammar-token-valuelist"><code class="xref docutils literal notranslate"><span class="pre">ValueList</span></code></a>] &quot;}&quot;
<strong id="grammar-token-valuelist">ValueList   </strong> ::=  <a class="reference internal" href="#grammar-token-valuelistne"><code class="xref docutils literal notranslate"><span class="pre">ValueListNE</span></code></a>
<strong id="grammar-token-valuelistne">ValueListNE </strong> ::=  <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a>)*
</pre>
<p>This value represents a sequence of bits, which can be used to initialize a
<code class="docutils literal notranslate"><span class="pre">bits&lt;</span></code><em>n</em><code class="docutils literal notranslate"><span class="pre">&gt;</span></code> field (note the braces). When doing so, the values
must represent a total of <em>n</em> bits.</p>
<pre>
<strong id="grammar-token-simplevalue4">SimpleValue4</strong> ::=  &quot;[&quot; <a class="reference internal" href="#grammar-token-valuelist"><code class="xref docutils literal notranslate"><span class="pre">ValueList</span></code></a> &quot;]&quot; [&quot;&lt;&quot; <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">Type</span></code></a> &quot;&gt;&quot;]
</pre>
<p>This value is a list initializer (note the brackets). The values in brackets
are the elements of the list. The optional <a class="reference internal" href="#grammar-token-type"><code class="xref std std-token docutils literal notranslate"><span class="pre">Type</span></code></a> can be used to
indicate a specific element type; otherwise the element type is inferred
from the given values. TableGen can usually infer the type, although
sometimes not when the value is the empty list (<code class="docutils literal notranslate"><span class="pre">[]</span></code>).</p>
<pre>
<strong id="grammar-token-simplevalue5">SimpleValue5</strong> ::=  &quot;(&quot; <a class="reference internal" href="#grammar-token-dagarg"><code class="xref docutils literal notranslate"><span class="pre">DagArg</span></code></a> [<a class="reference internal" href="#grammar-token-dagarglist"><code class="xref docutils literal notranslate"><span class="pre">DagArgList</span></code></a>] &quot;)&quot;
<strong id="grammar-token-dagarglist">DagArgList  </strong> ::=  <a class="reference internal" href="#grammar-token-dagarg"><code class="xref docutils literal notranslate"><span class="pre">DagArg</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-dagarg"><code class="xref docutils literal notranslate"><span class="pre">DagArg</span></code></a>)*
<strong id="grammar-token-dagarg">DagArg      </strong> ::=  <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> [&quot;:&quot; <a class="reference internal" href="#grammar-token-tokvarname"><code class="xref docutils literal notranslate"><span class="pre">TokVarName</span></code></a>] | <a class="reference internal" href="#grammar-token-tokvarname"><code class="xref docutils literal notranslate"><span class="pre">TokVarName</span></code></a>
</pre>
<p>This represents a DAG initializer (note the parentheses).  The first
<a class="reference internal" href="#grammar-token-dagarg"><code class="xref std std-token docutils literal notranslate"><span class="pre">DagArg</span></code></a> is called the “operator” of the DAG and must be a record.
See <a class="reference internal" href="#directed-acyclic-graphs-dags">Directed acyclic graphs (DAGs)</a> for more details.</p>
<pre>
<strong id="grammar-token-simplevalue6">SimpleValue6</strong> ::=  <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a>
</pre>
<p>The resulting value is the value of the entity named by the identifier. The
possible identifiers are described here, but the descriptions will make more
sense after reading the remainder of this guide.</p>
<ul>
<li><p class="first">A template argument of a <code class="docutils literal notranslate"><span class="pre">class</span></code>, such as the use of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="o">&lt;</span><span class="nb">int</span> <span class="n">Bar</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">Baz</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">The implicit template argument <code class="docutils literal notranslate"><span class="pre">NAME</span></code> in a <code class="docutils literal notranslate"><span class="pre">class</span></code> or <code class="docutils literal notranslate"><span class="pre">multiclass</span></code>
definition (see <a class="reference internal" href="#name">NAME</a>).</p>
</li>
<li><p class="first">A field local to a <code class="docutils literal notranslate"><span class="pre">class</span></code>, such as the use of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">Bar</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">Baz</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">The name of a record definition, such as the use of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> in the
definition of <code class="docutils literal notranslate"><span class="pre">Foo</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Bar</span> <span class="p">:</span> <span class="n">SomeClass</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">X</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">def</span> <span class="nf">Foo</span> <span class="p">{</span>
  <span class="n">SomeClass</span> <span class="n">Baz</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first">A field local to a record definition, such as the use of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Foo</span> <span class="p">{</span>
  <span class="nb">int</span> <span class="n">Bar</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="nb">int</span> <span class="n">Baz</span> <span class="o">=</span> <span class="n">Bar</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Fields inherited from the record’s parent classes can be accessed the same way.</p>
</li>
<li><p class="first">A template argument of a <code class="docutils literal notranslate"><span class="pre">multiclass</span></code>, such as the use of <code class="docutils literal notranslate"><span class="pre">Bar</span></code> in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>multiclass Foo &lt;int Bar&gt; {
  def : SomeClass&lt;Bar&gt;;
}
</pre></div>
</div>
</li>
<li><p class="first">A variable defined with the <code class="docutils literal notranslate"><span class="pre">defvar</span></code> or <code class="docutils literal notranslate"><span class="pre">defset</span></code> statements.</p>
</li>
<li><p class="first">The iteration variable of a <code class="docutils literal notranslate"><span class="pre">foreach</span></code>, such as the use of <code class="docutils literal notranslate"><span class="pre">i</span></code> in:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">foreach</span> <span class="n">i</span> <span class="o">=</span> <span class="mf">0.</span><span class="o">..</span><span class="mi">5</span> <span class="ow">in</span>
  <span class="k">def</span> <span class="nf">Foo</span><span class="c1">#i;</span>
</pre></div>
</div>
</li>
</ul>
<pre>
<strong id="grammar-token-simplevalue7">SimpleValue7</strong> ::=  <a class="reference internal" href="#grammar-token-classid"><code class="xref docutils literal notranslate"><span class="pre">ClassID</span></code></a> &quot;&lt;&quot; <a class="reference internal" href="#grammar-token-valuelistne"><code class="xref docutils literal notranslate"><span class="pre">ValueListNE</span></code></a> &quot;&gt;&quot;
</pre>
<p>This form creates a new anonymous record definition (as would be created by an
unnamed <code class="docutils literal notranslate"><span class="pre">def</span></code> inheriting from the given class with the given template
arguments; see <a class="reference internal" href="#def">def</a>) and the value is that record. A field of the record can be
obtained using a suffix; see <a class="reference internal" href="#suffixed-values">Suffixed Values</a>.</p>
<p>Invoking a class in this manner can provide a simple subroutine facility.
See <a class="reference internal" href="#using-classes-as-subroutines">Using Classes as Subroutines</a> for more information.</p>
<pre>
<strong id="grammar-token-simplevalue8">SimpleValue8</strong> ::=  <a class="reference internal" href="#grammar-token-bangoperator"><code class="xref docutils literal notranslate"><span class="pre">BangOperator</span></code></a> [&quot;&lt;&quot; <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">Type</span></code></a> &quot;&gt;&quot;] &quot;(&quot; <a class="reference internal" href="#grammar-token-valuelistne"><code class="xref docutils literal notranslate"><span class="pre">ValueListNE</span></code></a> &quot;)&quot;
                 | <a class="reference internal" href="#grammar-token-condoperator"><code class="xref docutils literal notranslate"><span class="pre">CondOperator</span></code></a> &quot;(&quot; <a class="reference internal" href="#grammar-token-condclause"><code class="xref docutils literal notranslate"><span class="pre">CondClause</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-condclause"><code class="xref docutils literal notranslate"><span class="pre">CondClause</span></code></a>)* &quot;)&quot;
<strong id="grammar-token-condclause">CondClause  </strong> ::=  <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a>
</pre>
<p>The bang operators provide functions that are not available with the other
simple values. Except in the case of <code class="docutils literal notranslate"><span class="pre">!cond</span></code>, a bang
operator takes a list of arguments enclosed in parentheses and performs some
function on those arguments, producing a value for that
bang operator. The <code class="docutils literal notranslate"><span class="pre">!cond</span></code> operator takes a list of pairs of arguments
separated by colons. See <a class="reference internal" href="#appendix-a-bang-operators">Appendix A: Bang Operators</a> for a description of
each bang operator.</p>
</div>
<div class="section" id="suffixed-values">
<h3><a class="toc-backref" href="#id12">1.5.2&nbsp;&nbsp;&nbsp;Suffixed values</a><a class="headerlink" href="#suffixed-values" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference internal" href="#grammar-token-simplevalue"><code class="xref std std-token docutils literal notranslate"><span class="pre">SimpleValue</span></code></a> values described above can be specified with
certain suffixes. The purpose of a suffix is to obtain a subvalue of the
primary value. Here are the possible suffixes for some primary <em>value</em>.</p>
<dl class="docutils">
<dt><em>value</em><code class="docutils literal notranslate"><span class="pre">{17}</span></code></dt>
<dd>The final value is bit 17 of the integer <em>value</em> (note the braces).</dd>
<dt><em>value</em><code class="docutils literal notranslate"><span class="pre">{8...15}</span></code></dt>
<dd>The final value is bits 8–15 of the integer <em>value</em>. The order of the
bits can be reversed by specifying <code class="docutils literal notranslate"><span class="pre">{15...8}</span></code>.</dd>
<dt><em>value</em><code class="docutils literal notranslate"><span class="pre">[4...7,17,2...3,4]</span></code></dt>
<dd>The final value is a new list that is a slice of the list <em>value</em> (note
the brackets). The
new list contains elements 4, 5, 6, 7, 17, 2, 3, and 4. Elements may be
included multiple times and in any order.</dd>
<dt><em>value</em><code class="docutils literal notranslate"><span class="pre">.</span></code> <em>field</em></dt>
<dd>The final value is the value of the specified <em>field</em> in the specified
record <em>value</em>.</dd>
</dl>
</div>
<div class="section" id="the-paste-operator">
<h3><a class="toc-backref" href="#id13">1.5.3&nbsp;&nbsp;&nbsp;The paste operator</a><a class="headerlink" href="#the-paste-operator" title="Permalink to this headline">¶</a></h3>
<p>The paste operator (<code class="docutils literal notranslate"><span class="pre">#</span></code>) is the only infix operator availabe in TableGen
expressions. It allows you to concatenate strings or lists, but has a few
unusual features.</p>
<p>The paste operator can be used when specifying the record name in a
<a class="reference internal" href="#grammar-token-def"><code class="xref std std-token docutils literal notranslate"><span class="pre">Def</span></code></a> or <a class="reference internal" href="#grammar-token-defm"><code class="xref std std-token docutils literal notranslate"><span class="pre">Defm</span></code></a> statement, in which case it must construct a
string. If an operand is an undefined name (<a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a>) or the
name of a global <a class="reference internal" href="#grammar-token-defvar"><code class="xref std std-token docutils literal notranslate"><span class="pre">Defvar</span></code></a> or <a class="reference internal" href="#grammar-token-defset"><code class="xref std std-token docutils literal notranslate"><span class="pre">Defset</span></code></a>, it is treated as a
verbatim string of characters. The value of a global name is not used.</p>
<p>The paste operator can be used in all other value expressions, in which case
it can construct a string or a list. Rather oddly, but consistent with the
previous case, if the <em>right-hand-side</em> operand is an undefined name or a
global name, it is treated as a verbatim string of characters. The
left-hand-side operand is treated normally.</p>
<p><a class="reference internal" href="#appendix-b-paste-operator-examples">Appendix B: Paste Operator Examples</a> presents examples of the behavior of
the paste operator.</p>
</div>
</div>
<div class="section" id="statements">
<h2><a class="toc-backref" href="#id14">1.6&nbsp;&nbsp;&nbsp;Statements</a><a class="headerlink" href="#statements" title="Permalink to this headline">¶</a></h2>
<p>The following statements may appear at the top level of TableGen source
files.</p>
<pre>
<strong id="grammar-token-tablegenfile">TableGenFile</strong> ::=  <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>*
<strong id="grammar-token-statement">Statement   </strong> ::=  <a class="reference internal" href="#grammar-token-class"><code class="xref docutils literal notranslate"><span class="pre">Class</span></code></a> | <a class="reference internal" href="#grammar-token-def"><code class="xref docutils literal notranslate"><span class="pre">Def</span></code></a> | <a class="reference internal" href="#grammar-token-defm"><code class="xref docutils literal notranslate"><span class="pre">Defm</span></code></a> | <a class="reference internal" href="#grammar-token-defset"><code class="xref docutils literal notranslate"><span class="pre">Defset</span></code></a> | <a class="reference internal" href="#grammar-token-defvar"><code class="xref docutils literal notranslate"><span class="pre">Defvar</span></code></a> | <a class="reference internal" href="#grammar-token-foreach"><code class="xref docutils literal notranslate"><span class="pre">Foreach</span></code></a>
                 | <a class="reference internal" href="#grammar-token-if"><code class="xref docutils literal notranslate"><span class="pre">If</span></code></a> | <a class="reference internal" href="#grammar-token-let"><code class="xref docutils literal notranslate"><span class="pre">Let</span></code></a> | <a class="reference internal" href="#grammar-token-multiclass"><code class="xref docutils literal notranslate"><span class="pre">MultiClass</span></code></a>
</pre>
<p>The following sections describe each of these top-level statements.</p>
<div class="section" id="class-define-an-abstract-record-class">
<h3><a class="toc-backref" href="#id15">1.6.1&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">class</span></code> — define an abstract record class</a><a class="headerlink" href="#class-define-an-abstract-record-class" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">class</span></code> statement defines an abstract record class from which other
classes and records can inherit.</p>
<pre>
<strong id="grammar-token-class">Class          </strong> ::=  &quot;class&quot; <a class="reference internal" href="#grammar-token-classid"><code class="xref docutils literal notranslate"><span class="pre">ClassID</span></code></a> [<a class="reference internal" href="#grammar-token-templatearglist"><code class="xref docutils literal notranslate"><span class="pre">TemplateArgList</span></code></a>] <a class="reference internal" href="#grammar-token-recordbody"><code class="xref docutils literal notranslate"><span class="pre">RecordBody</span></code></a>
<strong id="grammar-token-templatearglist">TemplateArgList</strong> ::=  &quot;&lt;&quot; <a class="reference internal" href="#grammar-token-templateargdecl"><code class="xref docutils literal notranslate"><span class="pre">TemplateArgDecl</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-templateargdecl"><code class="xref docutils literal notranslate"><span class="pre">TemplateArgDecl</span></code></a>)* &quot;&gt;&quot;
<strong id="grammar-token-templateargdecl">TemplateArgDecl</strong> ::=  <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">Type</span></code></a> <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> [&quot;=&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a>]
</pre>
<p>A class can be parameterized by a list of “template arguments,” whose values
can be used in the class’s record body.  These template arguments are
specified each time the class is inherited by another class or record.</p>
<p>If a template argument is not assigned a default value with <code class="docutils literal notranslate"><span class="pre">=</span></code>, it is
uninitialized (has the “value” <code class="docutils literal notranslate"><span class="pre">?</span></code>) and must be specified in the template
argument list when the class is inherited. If an argument is assigned a
default value, then it need not be specified in the argument list. The
template argument default values are evaluated from left to right.</p>
<p>The <a class="reference internal" href="#grammar-token-recordbody"><code class="xref std std-token docutils literal notranslate"><span class="pre">RecordBody</span></code></a> is defined below. It can include a list of
superclasses from which the current class inherits, along with field definitions
and other statements. When a class <code class="docutils literal notranslate"><span class="pre">C</span></code> inherits from another class <code class="docutils literal notranslate"><span class="pre">D</span></code>,
the fields of <code class="docutils literal notranslate"><span class="pre">D</span></code> are effectively merged into the fields of <code class="docutils literal notranslate"><span class="pre">C</span></code>.</p>
<p>A given class can only be defined once. A <code class="docutils literal notranslate"><span class="pre">class</span></code> statement is
considered to define the class if <em>any</em> of the following are true (the
<a class="reference internal" href="#grammar-token-recordbody"><code class="xref std std-token docutils literal notranslate"><span class="pre">RecordBody</span></code></a> elements are described below).</p>
<ul class="simple">
<li>The <a class="reference internal" href="#grammar-token-templatearglist"><code class="xref std std-token docutils literal notranslate"><span class="pre">TemplateArgList</span></code></a> is present, or</li>
<li>The <a class="reference internal" href="#grammar-token-parentclasslist"><code class="xref std std-token docutils literal notranslate"><span class="pre">ParentClassList</span></code></a> in the <a class="reference internal" href="#grammar-token-recordbody"><code class="xref std std-token docutils literal notranslate"><span class="pre">RecordBody</span></code></a> is present, or</li>
<li>The <a class="reference internal" href="#grammar-token-body"><code class="xref std std-token docutils literal notranslate"><span class="pre">Body</span></code></a> in the <a class="reference internal" href="#grammar-token-recordbody"><code class="xref std std-token docutils literal notranslate"><span class="pre">RecordBody</span></code></a> is present and not empty.</li>
</ul>
<p>You can declare an empty class by specifying an empty <a class="reference internal" href="#grammar-token-templatearglist"><code class="xref std std-token docutils literal notranslate"><span class="pre">TemplateArgList</span></code></a>
and an empty <a class="reference internal" href="#grammar-token-recordbody"><code class="xref std std-token docutils literal notranslate"><span class="pre">RecordBody</span></code></a>. This can serve as a restricted form of
forward declaration. Note that records derived from a forward-declared
class will inherit no fields from it, because those records are built when
their declarations are parsed, and thus before the class is finally defined.</p>
<p id="name">Every class has an implicit template argument named <code class="docutils literal notranslate"><span class="pre">NAME</span></code> (uppercase),
which is bound to the name of the <a class="reference internal" href="#grammar-token-def"><code class="xref std std-token docutils literal notranslate"><span class="pre">Def</span></code></a> or <a class="reference internal" href="#grammar-token-defm"><code class="xref std std-token docutils literal notranslate"><span class="pre">Defm</span></code></a> inheriting
the class. The value of <code class="docutils literal notranslate"><span class="pre">NAME</span></code> is undefined if the class is inherited by
an anonymous record.</p>
<p>See <a class="reference internal" href="#examples-classes-and-records">Examples: classes and records</a> for examples.</p>
<div class="section" id="record-bodies">
<h4><a class="toc-backref" href="#id16">1.6.1.1&nbsp;&nbsp;&nbsp;Record Bodies</a><a class="headerlink" href="#record-bodies" title="Permalink to this headline">¶</a></h4>
<p>Record bodies appear in both class and record definitions. A record body can
include a parent class list, which specifies the classes from which the
current class or record inherits fields. Such classes are called the
superclasses or parent classes of the class or record. The record body also
includes the main body of the definition, which contains the specification
of the fields of the class or record.</p>
<pre>
<strong id="grammar-token-recordbody">RecordBody       </strong> ::=  <a class="reference internal" href="#grammar-token-parentclasslist"><code class="xref docutils literal notranslate"><span class="pre">ParentClassList</span></code></a> <a class="reference internal" href="#grammar-token-body"><code class="xref docutils literal notranslate"><span class="pre">Body</span></code></a>
<strong id="grammar-token-parentclasslist">ParentClassList  </strong> ::=  [&quot;:&quot; <a class="reference internal" href="#grammar-token-parentclasslistne"><code class="xref docutils literal notranslate"><span class="pre">ParentClassListNE</span></code></a>]
<strong id="grammar-token-parentclasslistne">ParentClassListNE</strong> ::=  <a class="reference internal" href="#grammar-token-classref"><code class="xref docutils literal notranslate"><span class="pre">ClassRef</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-classref"><code class="xref docutils literal notranslate"><span class="pre">ClassRef</span></code></a>)*
<strong id="grammar-token-classref">ClassRef         </strong> ::=  (<a class="reference internal" href="#grammar-token-classid"><code class="xref docutils literal notranslate"><span class="pre">ClassID</span></code></a> | <a class="reference internal" href="#grammar-token-multiclassid"><code class="xref docutils literal notranslate"><span class="pre">MultiClassID</span></code></a>) [&quot;&lt;&quot; <a class="reference internal" href="#grammar-token-valuelist"><code class="xref docutils literal notranslate"><span class="pre">ValueList</span></code></a> &quot;&gt;&quot;]
</pre>
<p>A <a class="reference internal" href="#grammar-token-parentclasslist"><code class="xref std std-token docutils literal notranslate"><span class="pre">ParentClassList</span></code></a> containing a <a class="reference internal" href="#grammar-token-multiclassid"><code class="xref std std-token docutils literal notranslate"><span class="pre">MultiClassID</span></code></a> is valid only
in the class list of a <code class="docutils literal notranslate"><span class="pre">defm</span></code> statement. In that case, the ID must be the
name of a multiclass.</p>
<pre>
<strong id="grammar-token-body">Body    </strong> ::=  &quot;;&quot; | &quot;{&quot; <a class="reference internal" href="#grammar-token-bodyitem"><code class="xref docutils literal notranslate"><span class="pre">BodyItem</span></code></a>* &quot;}&quot;
<strong id="grammar-token-bodyitem">BodyItem</strong> ::=  <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">Type</span></code></a> <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> [&quot;=&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a>] &quot;;&quot;
             | &quot;let&quot; <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> [&quot;{&quot; <a class="reference internal" href="#grammar-token-rangelist"><code class="xref docutils literal notranslate"><span class="pre">RangeList</span></code></a> &quot;}&quot;] &quot;=&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> &quot;;&quot;
             | &quot;defvar&quot; <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> &quot;;&quot;
</pre>
<p>A field definition in the body specifies a field to be included in the class
or record. If no initial value is specified, then the field’s value is
uninitialized. The type must be specified; TableGen will not infer it from
the value.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">let</span></code> form is used to reset a field to a new value. This can be done
for fields defined directly in the body or fields inherited from
superclasses.  A <a class="reference internal" href="#grammar-token-rangelist"><code class="xref std std-token docutils literal notranslate"><span class="pre">RangeList</span></code></a> can be specified to reset certain bits
in a <code class="docutils literal notranslate"><span class="pre">bit&lt;n&gt;</span></code> field.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">defvar</span></code> form defines a variable whose value can be used in other
value expressions within the body. The variable is not a field: it does not
become a field of the class or record being defined. Variables are provided
to hold temporary values while processing the body. See <a class="reference internal" href="#defvar-in-a-record-body">Defvar in a Record
Body</a> for more details.</p>
<p>When class <code class="docutils literal notranslate"><span class="pre">C2</span></code> inherits from class <code class="docutils literal notranslate"><span class="pre">C1</span></code>, it acquires all the field
definitions of <code class="docutils literal notranslate"><span class="pre">C1</span></code>. As those definitions are merged into class <code class="docutils literal notranslate"><span class="pre">C2</span></code>, any
template arguments passed to <code class="docutils literal notranslate"><span class="pre">C1</span></code> by <code class="docutils literal notranslate"><span class="pre">C2</span></code> are substituted into the
definitions. In other words, the abstract record fields defined by <code class="docutils literal notranslate"><span class="pre">C1</span></code> are
expanded with the template arguments before being merged into <code class="docutils literal notranslate"><span class="pre">C2</span></code>.</p>
</div>
</div>
<div class="section" id="def-define-a-concrete-record">
<span id="def"></span><h3><a class="toc-backref" href="#id17">1.6.2&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">def</span></code> — define a concrete record</a><a class="headerlink" href="#def-define-a-concrete-record" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">def</span></code> statement defines a new concrete record.</p>
<pre>
<strong id="grammar-token-def">Def      </strong> ::=  &quot;def&quot; [<a class="reference internal" href="#grammar-token-namevalue"><code class="xref docutils literal notranslate"><span class="pre">NameValue</span></code></a>] <a class="reference internal" href="#grammar-token-recordbody"><code class="xref docutils literal notranslate"><span class="pre">RecordBody</span></code></a>
<strong id="grammar-token-namevalue">NameValue</strong> ::=  <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> (parsed in a special manner)
</pre>
<p>The name value is optional. If specified, it is parsed in a special mode
where undefined (unrecognized) identifiers are interpreted as literal
strings. In particular, global identifiers are considered unrecognized.
These include global variables defined by <code class="docutils literal notranslate"><span class="pre">defvar</span></code> and <code class="docutils literal notranslate"><span class="pre">defset</span></code>.</p>
<p>If no name value is given, the record is <em>anonymous</em>. The final name of an
anonymous record is unspecified but globally unique.</p>
<p>Special handling occurs if a <code class="docutils literal notranslate"><span class="pre">def</span></code> appears inside a <code class="docutils literal notranslate"><span class="pre">multiclass</span></code>
statement. See the <code class="docutils literal notranslate"><span class="pre">multiclass</span></code> section below for details.</p>
<p>A record can inherit from one or more classes by specifying the
<a class="reference internal" href="#grammar-token-parentclasslist"><code class="xref std std-token docutils literal notranslate"><span class="pre">ParentClassList</span></code></a> clause at the beginning of its record body. All of
the fields in the parent classes are added to the record. If two or more
parent classes provide the same field, the record ends up with the field value
of the last parent class.</p>
<p>As a special case, the name of a record can be passed in a template argument
to that record’s superclasses. For example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class A &lt;dag d&gt; {
  dag the_dag = d;
}

def rec1 : A&lt;(ops rec1)&gt;
</pre></div>
</div>
<p>The DAG <code class="docutils literal notranslate"><span class="pre">(ops</span> <span class="pre">rec1)</span></code> is passed as a template argument to class <code class="docutils literal notranslate"><span class="pre">A</span></code>. Notice
that the DAG includes <code class="docutils literal notranslate"><span class="pre">rec1</span></code>, the record being defined.</p>
<p>The steps taken to create a new record are somewhat complex. See <a class="reference internal" href="#how-records-are-built">How
records are built</a>.</p>
<p>See <a class="reference internal" href="#examples-classes-and-records">Examples: classes and records</a> for examples.</p>
</div>
<div class="section" id="examples-classes-and-records">
<h3><a class="toc-backref" href="#id18">1.6.3&nbsp;&nbsp;&nbsp;Examples: classes and records</a><a class="headerlink" href="#examples-classes-and-records" title="Permalink to this headline">¶</a></h3>
<p>Here is a simple TableGen file with one class and two record definitions.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class C {
  bit V = 1;
}

def X : C;
def Y : C {
  let V = 0;
  string Greeting = &quot;Hello!&quot;;
}
</pre></div>
</div>
<p>First, the abstract class <code class="docutils literal notranslate"><span class="pre">C</span></code> is defined. It has one field named <code class="docutils literal notranslate"><span class="pre">V</span></code>
that is a bit initialized to 1.</p>
<p>Next, two records are defined, derived from class <code class="docutils literal notranslate"><span class="pre">C</span></code>; that is, with <code class="docutils literal notranslate"><span class="pre">C</span></code>
as their superclass. Thus they both inherit the <code class="docutils literal notranslate"><span class="pre">V</span></code> field. Record <code class="docutils literal notranslate"><span class="pre">Y</span></code>
also defines another string field, <code class="docutils literal notranslate"><span class="pre">Greeting</span></code>, which is initialized to
<code class="docutils literal notranslate"><span class="pre">&quot;Hello!&quot;</span></code>. In addition, <code class="docutils literal notranslate"><span class="pre">Y</span></code> overrides the inherited <code class="docutils literal notranslate"><span class="pre">V</span></code> field,
setting it to 0.</p>
<p>A class is useful for isolating the common features of multiple records in
one place. A class can initialize common fields to default values, but
records inheriting from that class can override the defaults.</p>
<p>TableGen supports the definition of parameterized classes as well as
nonparameterized ones. Parameterized classes specify a list of variable
declarations, which may optionally have defaults, that are bound when the
class is specified as a superclass of another class or record.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class FPFormat &lt;bits&lt;3&gt; val&gt; {
  bits&lt;3&gt; Value = val;
}

def NotFP      : FPFormat&lt;0&gt;;
def ZeroArgFP  : FPFormat&lt;1&gt;;
def OneArgFP   : FPFormat&lt;2&gt;;
def OneArgFPRW : FPFormat&lt;3&gt;;
def TwoArgFP   : FPFormat&lt;4&gt;;
def CompareFP  : FPFormat&lt;5&gt;;
def CondMovFP  : FPFormat&lt;6&gt;;
def SpecialFP  : FPFormat&lt;7&gt;;
</pre></div>
</div>
<p>The purpose of the <code class="docutils literal notranslate"><span class="pre">FPFormat</span></code> class is to act as a sort of enumerated
type. It provides a single field, <code class="docutils literal notranslate"><span class="pre">Value</span></code>, which holds a 3-bit number. Its
template argument, <code class="docutils literal notranslate"><span class="pre">val</span></code>, is used to set the <code class="docutils literal notranslate"><span class="pre">Value</span></code> field.
Each of the eight records is defined with <code class="docutils literal notranslate"><span class="pre">FPFormat</span></code> as its superclass. The
enumeration value is passed in angle brackets as the template argument. Each
record will inherent the <code class="docutils literal notranslate"><span class="pre">Value</span></code> field with the appropriate enumeration
value.</p>
<p>Here is a more complex example of classes with template arguments. First, we
define a class similar to the <code class="docutils literal notranslate"><span class="pre">FPFormat</span></code> class above. It takes a template
argument and uses it to initialize a field named <code class="docutils literal notranslate"><span class="pre">Value</span></code>. Then we define
four records that inherit the <code class="docutils literal notranslate"><span class="pre">Value</span></code> field with its four different
integer values.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class ModRefVal &lt;bits&lt;2&gt; val&gt; {
  bits&lt;2&gt; Value = val;
}

def None   : ModRefVal&lt;0&gt;;
def Mod    : ModRefVal&lt;1&gt;;
def Ref    : ModRefVal&lt;2&gt;;
def ModRef : ModRefVal&lt;3&gt;;
</pre></div>
</div>
<p>This is somewhat contrived, but let’s say we would like to examine the two
bits of the <code class="docutils literal notranslate"><span class="pre">Value</span></code> field independently. We can define a class that
accepts a <code class="docutils literal notranslate"><span class="pre">ModRefVal</span></code> record as a template argument and splits up its
value into two fields, one bit each. Then we can define records that inherit from
<code class="docutils literal notranslate"><span class="pre">ModRefBits</span></code> and so acquire two fields from it, one for each bit in the
<code class="docutils literal notranslate"><span class="pre">ModRefVal</span></code> record passed as the template argument.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class ModRefBits &lt;ModRefVal mrv&gt; {
  // Break the value up into its bits, which can provide a nice
  // interface to the ModRefVal values.
  bit isMod = mrv.Value{0};
  bit isRef = mrv.Value{1};
}

// Example uses.
def foo   : ModRefBits&lt;Mod&gt;;
def bar   : ModRefBits&lt;Ref&gt;;
def snork : ModRefBits&lt;ModRef&gt;;
</pre></div>
</div>
<p>This illustrates how one class can be defined to reorganize the
fields in another class, thus hiding the internal representation of that
other class.</p>
<p>Running <code class="docutils literal notranslate"><span class="pre">llvm-tblgen</span></code> on the example prints the following definitions:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def bar {      // Value
  bit isMod = 0;
  bit isRef = 1;
}
def foo {      // Value
  bit isMod = 1;
  bit isRef = 0;
}
def snork {      // Value
  bit isMod = 1;
  bit isRef = 1;
}
</pre></div>
</div>
</div>
<div class="section" id="let-override-fields-in-classes-or-records">
<h3><a class="toc-backref" href="#id19">1.6.4&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">let</span></code> — override fields in classes or records</a><a class="headerlink" href="#let-override-fields-in-classes-or-records" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">let</span></code> statement collects a set of field values (sometimes called
<em>bindings</em>) and applies them to all the classes and records defined by
statements within the scope of the <code class="docutils literal notranslate"><span class="pre">let</span></code>.</p>
<pre>
<strong id="grammar-token-let">Let    </strong> ::=   &quot;let&quot; <a class="reference internal" href="#grammar-token-letlist"><code class="xref docutils literal notranslate"><span class="pre">LetList</span></code></a> &quot;in&quot; &quot;{&quot; <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>* &quot;}&quot;
            | &quot;let&quot; <a class="reference internal" href="#grammar-token-letlist"><code class="xref docutils literal notranslate"><span class="pre">LetList</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>
<strong id="grammar-token-letlist">LetList</strong> ::=  <a class="reference internal" href="#grammar-token-letitem"><code class="xref docutils literal notranslate"><span class="pre">LetItem</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-letitem"><code class="xref docutils literal notranslate"><span class="pre">LetItem</span></code></a>)*
<strong id="grammar-token-letitem">LetItem</strong> ::=  <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> [&quot;&lt;&quot; <a class="reference internal" href="#grammar-token-rangelist"><code class="xref docutils literal notranslate"><span class="pre">RangeList</span></code></a> &quot;&gt;&quot;] &quot;=&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a>
</pre>
<p>The <code class="docutils literal notranslate"><span class="pre">let</span></code> statement establishes a scope, which is a sequence of statements
in braces or a single statement with no braces. The bindings in the
<a class="reference internal" href="#grammar-token-letlist"><code class="xref std std-token docutils literal notranslate"><span class="pre">LetList</span></code></a> apply to the statements in that scope.</p>
<p>The field names in the <a class="reference internal" href="#grammar-token-letlist"><code class="xref std std-token docutils literal notranslate"><span class="pre">LetList</span></code></a> must name fields in classes inherited by
the classes and records defined in the statements. The field values are
applied to the classes and records <em>after</em> the records inherit all the fields from
their superclasses. So the <code class="docutils literal notranslate"><span class="pre">let</span></code> acts to override inherited field
values. A <code class="docutils literal notranslate"><span class="pre">let</span></code> cannot override the value of a template argument.</p>
<p>Top-level <code class="docutils literal notranslate"><span class="pre">let</span></code> statements are often useful when a few fields need to be
overriden in several records. Here are two examples. Note that <code class="docutils literal notranslate"><span class="pre">let</span></code>
statements can be nested.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>let isTerminator = 1, isReturn = 1, isBarrier = 1, hasCtrlDep = 1 in
  def RET : I&lt;0xC3, RawFrm, (outs), (ins), &quot;ret&quot;, [(X86retflag 0)]&gt;;

let isCall = 1 in
  // All calls clobber the non-callee saved registers...
  let Defs = [EAX, ECX, EDX, FP0, FP1, FP2, FP3, FP4, FP5, FP6, ST0,
              MM0, MM1, MM2, MM3, MM4, MM5, MM6, MM7, XMM0, XMM1, XMM2,
              XMM3, XMM4, XMM5, XMM6, XMM7, EFLAGS] in {
    def CALLpcrel32 : Ii32&lt;0xE8, RawFrm, (outs), (ins i32imm:$dst, variable_ops),
                           &quot;call\t${dst:call}&quot;, []&gt;;
    def CALL32r     : I&lt;0xFF, MRM2r, (outs), (ins GR32:$dst, variable_ops),
                        &quot;call\t{*}$dst&quot;, [(X86call GR32:$dst)]&gt;;
    def CALL32m     : I&lt;0xFF, MRM2m, (outs), (ins i32mem:$dst, variable_ops),
                        &quot;call\t{*}$dst&quot;, []&gt;;
  }
</pre></div>
</div>
<p>Note that a top-level <code class="docutils literal notranslate"><span class="pre">let</span></code> will not override fields defined in the classes or records
themselves.</p>
</div>
<div class="section" id="multiclass-define-multiple-records">
<h3><a class="toc-backref" href="#id20">1.6.5&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">multiclass</span></code> — define multiple records</a><a class="headerlink" href="#multiclass-define-multiple-records" title="Permalink to this headline">¶</a></h3>
<p>While classes with template arguments are a good way to factor out commonality
between multiple records, multiclasses allow a convenient method for
defining multiple records at once. For example, consider a 3-address
instruction architecture whose instructions come in two formats: <code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span>
<span class="pre">op</span> <span class="pre">reg</span></code> and <code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span> <span class="pre">op</span> <span class="pre">imm</span></code> (e.g., SPARC). We would like to specify in
one place that these two common formats exist, then in a separate place
specify what all the operations are. The <code class="docutils literal notranslate"><span class="pre">multiclass</span></code> and <code class="docutils literal notranslate"><span class="pre">defm</span></code>
statements accomplish this goal. You can think of a multiclass as a macro or
template that expands into multiple records.</p>
<pre>
<strong id="grammar-token-multiclass">MultiClass          </strong> ::=  &quot;multiclass&quot; <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> [<a class="reference internal" href="#grammar-token-templatearglist"><code class="xref docutils literal notranslate"><span class="pre">TemplateArgList</span></code></a>]
                          [&quot;:&quot; <a class="reference internal" href="#grammar-token-parentmulticlasslist"><code class="xref docutils literal notranslate"><span class="pre">ParentMultiClassList</span></code></a>]
                          &quot;{&quot; <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>+ &quot;}&quot;
<strong id="grammar-token-parentmulticlasslist">ParentMultiClassList</strong> ::=  <a class="reference internal" href="#grammar-token-multiclassid"><code class="xref docutils literal notranslate"><span class="pre">MultiClassID</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-multiclassid"><code class="xref docutils literal notranslate"><span class="pre">MultiClassID</span></code></a>)*
<strong id="grammar-token-multiclassid">MultiClassID        </strong> ::=  <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a>
</pre>
<p>As with regular classes, the multiclass has a name and can accept template
arguments. A multiclass can inherit from other multiclasses, which causes
the other multiclasses to be expanded and contribute to the record
definitions in the inheriting multiclass. The body of the multiclass
contains a series of statements that define records, using <a class="reference internal" href="#grammar-token-def"><code class="xref std std-token docutils literal notranslate"><span class="pre">Def</span></code></a> and
<a class="reference internal" href="#grammar-token-defm"><code class="xref std std-token docutils literal notranslate"><span class="pre">Defm</span></code></a>. In addition, <a class="reference internal" href="#grammar-token-defvar"><code class="xref std std-token docutils literal notranslate"><span class="pre">Defvar</span></code></a>, <a class="reference internal" href="#grammar-token-foreach"><code class="xref std std-token docutils literal notranslate"><span class="pre">Foreach</span></code></a>, and
<a class="reference internal" href="#grammar-token-let"><code class="xref std std-token docutils literal notranslate"><span class="pre">Let</span></code></a> statements can be used to factor out even more common elements.
The <a class="reference internal" href="#grammar-token-if"><code class="xref std std-token docutils literal notranslate"><span class="pre">If</span></code></a> statement can also be used.</p>
<p>Also as with regular classes, the multiclass has the implicit template
argument <code class="docutils literal notranslate"><span class="pre">NAME</span></code> (see <a class="reference internal" href="#name">NAME</a>). When a named (non-anonymous) record is
defined in a multiclass and the record’s name does not contain a use of the
template argument <code class="docutils literal notranslate"><span class="pre">NAME</span></code>, such a use is automatically prepended
to the name.  That is, the following are equivalent inside a multiclass:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">Foo</span> <span class="o">...</span>
<span class="k">def</span> <span class="nf">NAME</span><span class="c1">#Foo ...</span>
</pre></div>
</div>
<p>The records defined in a multiclass are instantiated when the multiclass is
“invoked” by a <code class="docutils literal notranslate"><span class="pre">defm</span></code> statement outside the multiclass definition. Each
<code class="docutils literal notranslate"><span class="pre">def</span></code> statement produces a record. As with top-level <code class="docutils literal notranslate"><span class="pre">def</span></code> statements,
these definitions can inherit from multiple superclasses.</p>
<p>See <a class="reference internal" href="#examples-multiclasses-and-defms">Examples: multiclasses and defms</a> for examples.</p>
</div>
<div class="section" id="defm-invoke-multiclasses-to-define-multiple-records">
<h3><a class="toc-backref" href="#id21">1.6.6&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">defm</span></code> — invoke multiclasses to define multiple records</a><a class="headerlink" href="#defm-invoke-multiclasses-to-define-multiple-records" title="Permalink to this headline">¶</a></h3>
<p>Once multiclasses have been defined, you use the <code class="docutils literal notranslate"><span class="pre">defm</span></code> statement to
“invoke” multiclasses and process the multiple record definitions in those
multiclasses. Those record definitions are specified by <code class="docutils literal notranslate"><span class="pre">def</span></code>
statements in the multiclasses, and indirectly by <code class="docutils literal notranslate"><span class="pre">defm</span></code> statements.</p>
<pre>
<strong id="grammar-token-defm">Defm</strong> ::=  &quot;defm&quot; [<a class="reference internal" href="#grammar-token-namevalue"><code class="xref docutils literal notranslate"><span class="pre">NameValue</span></code></a>] <a class="reference internal" href="#grammar-token-parentclasslist"><code class="xref docutils literal notranslate"><span class="pre">ParentClassList</span></code></a> &quot;;&quot;
</pre>
<p>The optional <a class="reference internal" href="#grammar-token-namevalue"><code class="xref std std-token docutils literal notranslate"><span class="pre">NameValue</span></code></a> is formed in the same way as the name of a
<code class="docutils literal notranslate"><span class="pre">def</span></code>. The <a class="reference internal" href="#grammar-token-parentclasslist"><code class="xref std std-token docutils literal notranslate"><span class="pre">ParentClassList</span></code></a> is a colon followed by a list of at least one
multiclass and any number of regular classes. The multiclasses must
precede the regular classes. Note that the <code class="docutils literal notranslate"><span class="pre">defm</span></code> does not have a body.</p>
<p>This statement instantiates all the records defined in all the specified
multiclasses, either directly by <code class="docutils literal notranslate"><span class="pre">def</span></code> statements or indirectly by
<code class="docutils literal notranslate"><span class="pre">defm</span></code> statements. These records also receive the fields defined in any
regular classes included in the parent class list. This is useful for adding
a common set of fields to all the records created by the <code class="docutils literal notranslate"><span class="pre">defm</span></code>.</p>
<p>The name is parsed in the same special mode used by <code class="docutils literal notranslate"><span class="pre">def</span></code>. If the name is
not included, a globally unique name is provided. That is, the following
examples end up with different names:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">defm</span>    <span class="p">:</span> <span class="n">SomeMultiClass</span><span class="o">&lt;...&gt;</span><span class="p">;</span>   <span class="o">//</span> <span class="n">A</span> <span class="n">globally</span> <span class="n">unique</span> <span class="n">name</span><span class="o">.</span>
<span class="n">defm</span> <span class="s2">&quot;&quot;</span> <span class="p">:</span> <span class="n">SomeMultiClass</span><span class="o">&lt;...&gt;</span><span class="p">;</span>   <span class="o">//</span> <span class="n">An</span> <span class="n">empty</span> <span class="n">name</span><span class="o">.</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">defm</span></code> statement can be used in a multiclass body. When this occurs,
the second variant is equivalent to:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">defm</span> <span class="n">NAME</span> <span class="p">:</span> <span class="n">SomeMultiClass</span><span class="o">&lt;...&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>More generally, when <code class="docutils literal notranslate"><span class="pre">defm</span></code> occurs in a multiclass and its name does not
include a use of the implicit template argument <code class="docutils literal notranslate"><span class="pre">NAME</span></code>, then <code class="docutils literal notranslate"><span class="pre">NAME</span></code> will
be prepended automatically. That is, the following are equivalent inside a
multiclass:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">defm</span> <span class="n">Foo</span>      <span class="p">:</span> <span class="n">SomeMultiClass</span><span class="o">&lt;...&gt;</span><span class="p">;</span>
<span class="n">defm</span> <span class="n">NAME</span><span class="c1">#Foo : SomeMultiClass&lt;...&gt;;</span>
</pre></div>
</div>
<p>See <a class="reference internal" href="#examples-multiclasses-and-defms">Examples: multiclasses and defms</a> for examples.</p>
</div>
<div class="section" id="examples-multiclasses-and-defms">
<h3><a class="toc-backref" href="#id22">1.6.7&nbsp;&nbsp;&nbsp;Examples: multiclasses and defms</a><a class="headerlink" href="#examples-multiclasses-and-defms" title="Permalink to this headline">¶</a></h3>
<p>Here is a simple example using <code class="docutils literal notranslate"><span class="pre">multiclass</span></code> and <code class="docutils literal notranslate"><span class="pre">defm</span></code>.  Consider a
3-address instruction architecture whose instructions come in two formats:
<code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span> <span class="pre">op</span> <span class="pre">reg</span></code> and <code class="docutils literal notranslate"><span class="pre">reg</span> <span class="pre">=</span> <span class="pre">reg</span> <span class="pre">op</span> <span class="pre">imm</span></code> (immediate). The SPARC is an
example of such an architecture.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ops;
def GPR;
def Imm;
class inst &lt;int opc, string asmstr, dag operandlist&gt;;

multiclass ri_inst &lt;int opc, string asmstr&gt; {
  def _rr : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
                   (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;;
  def _ri : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
                   (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;;
}

// Define records for each instruction in the RR and RI formats.
defm ADD : ri_inst&lt;0b111, &quot;add&quot;&gt;;
defm SUB : ri_inst&lt;0b101, &quot;sub&quot;&gt;;
defm MUL : ri_inst&lt;0b100, &quot;mul&quot;&gt;;
</pre></div>
</div>
<p>Each use of the <code class="docutils literal notranslate"><span class="pre">ri_inst</span></code> multiclass defines two records, one with the
<code class="docutils literal notranslate"><span class="pre">_rr</span></code> suffix and one with <code class="docutils literal notranslate"><span class="pre">_ri</span></code>. Recall that the name of the <code class="docutils literal notranslate"><span class="pre">defm</span></code>
that uses a multiclass is prepended to the names of the records defined in
that multiclass. So the resulting definitions are named:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADD_rr</span><span class="p">,</span> <span class="n">ADD_ri</span>
<span class="n">SUB_rr</span><span class="p">,</span> <span class="n">SUB_ri</span>
<span class="n">MUL_rr</span><span class="p">,</span> <span class="n">MUL_ri</span>
</pre></div>
</div>
<p>Without the <code class="docutils literal notranslate"><span class="pre">multiclass</span></code> feature, the instructions would have to be
defined as follows.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ops;
def GPR;
def Imm;
class inst &lt;int opc, string asmstr, dag operandlist&gt;;

class rrinst &lt;int opc, string asmstr&gt;
  : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
           (ops GPR:$dst, GPR:$src1, GPR:$src2)&gt;;

class riinst &lt;int opc, string asmstr&gt;
  : inst&lt;opc, !strconcat(asmstr, &quot; $dst, $src1, $src2&quot;),
           (ops GPR:$dst, GPR:$src1, Imm:$src2)&gt;;

// Define records for each instruction in the RR and RI formats.
def ADD_rr : rrinst&lt;0b111, &quot;add&quot;&gt;;
def ADD_ri : riinst&lt;0b111, &quot;add&quot;&gt;;
def SUB_rr : rrinst&lt;0b101, &quot;sub&quot;&gt;;
def SUB_ri : riinst&lt;0b101, &quot;sub&quot;&gt;;
def MUL_rr : rrinst&lt;0b100, &quot;mul&quot;&gt;;
def MUL_ri : riinst&lt;0b100, &quot;mul&quot;&gt;;
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">defm</span></code> can be used in a multiclass to “invoke” other multiclasses and
create the records defined in those multiclasses in addition to the records
defined in the current multiclass. In the following example, the <code class="docutils literal notranslate"><span class="pre">basic_s</span></code>
and <code class="docutils literal notranslate"><span class="pre">basic_p</span></code> multiclasses contain <code class="docutils literal notranslate"><span class="pre">defm</span></code> statements that refer to the
<code class="docutils literal notranslate"><span class="pre">basic_r</span></code> multiclass. The <code class="docutils literal notranslate"><span class="pre">basic_r</span></code> multiclass contains only <code class="docutils literal notranslate"><span class="pre">def</span></code>
statements.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class Instruction &lt;bits&lt;4&gt; opc, string Name&gt; {
  bits&lt;4&gt; opcode = opc;
  string name = Name;
}

multiclass basic_r &lt;bits&lt;4&gt; opc&gt; {
  def rr : Instruction&lt;opc, &quot;rr&quot;&gt;;
  def rm : Instruction&lt;opc, &quot;rm&quot;&gt;;
}

multiclass basic_s &lt;bits&lt;4&gt; opc&gt; {
  defm SS : basic_r&lt;opc&gt;;
  defm SD : basic_r&lt;opc&gt;;
  def X : Instruction&lt;opc, &quot;x&quot;&gt;;
}

multiclass basic_p &lt;bits&lt;4&gt; opc&gt; {
  defm PS : basic_r&lt;opc&gt;;
  defm PD : basic_r&lt;opc&gt;;
  def Y : Instruction&lt;opc, &quot;y&quot;&gt;;
}

defm ADD : basic_s&lt;0xf&gt;, basic_p&lt;0xf&gt;;
</pre></div>
</div>
<p>The final <code class="docutils literal notranslate"><span class="pre">defm</span></code> creates the following records, five from the <code class="docutils literal notranslate"><span class="pre">basic_s</span></code>
multiclass and five from the <code class="docutils literal notranslate"><span class="pre">basic_p</span></code> multiclass:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ADDSSrr</span><span class="p">,</span> <span class="n">ADDSSrm</span>
<span class="n">ADDSDrr</span><span class="p">,</span> <span class="n">ADDSDrm</span>
<span class="n">ADDX</span>
<span class="n">ADDPSrr</span><span class="p">,</span> <span class="n">ADDPSrm</span>
<span class="n">ADDPDrr</span><span class="p">,</span> <span class="n">ADDPDrm</span>
<span class="n">ADDY</span>
</pre></div>
</div>
<p>A <code class="docutils literal notranslate"><span class="pre">defm</span></code> statement, both at top level and in a multiclass, can inherit
from regular classes in addition to multiclasses. The rule is that the
regular classes must be listed after the multiclasses, and there must be at least
one multiclass.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class XD {
  bits&lt;4&gt; Prefix = 11;
}
class XS {
  bits&lt;4&gt; Prefix = 12;
}
class I &lt;bits&lt;4&gt; op&gt; {
  bits&lt;4&gt; opcode = op;
}

multiclass R {
  def rr : I&lt;4&gt;;
  def rm : I&lt;2&gt;;
}

multiclass Y {
  defm SS : R, XD;    // First multiclass R, then regular class XD.
  defm SD : R, XS;
}

defm Instr : Y;
</pre></div>
</div>
<p>This example will create four records, shown here in alphabetical order with
their fields.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def InstrSDrm {
  bits&lt;4&gt; opcode = { 0, 0, 1, 0 };
  bits&lt;4&gt; Prefix = { 1, 1, 0, 0 };
}

def InstrSDrr {
  bits&lt;4&gt; opcode = { 0, 1, 0, 0 };
  bits&lt;4&gt; Prefix = { 1, 1, 0, 0 };
}

def InstrSSrm {
  bits&lt;4&gt; opcode = { 0, 0, 1, 0 };
  bits&lt;4&gt; Prefix = { 1, 0, 1, 1 };
}

def InstrSSrr {
  bits&lt;4&gt; opcode = { 0, 1, 0, 0 };
  bits&lt;4&gt; Prefix = { 1, 0, 1, 1 };
}
</pre></div>
</div>
<p>It’s also possible to use <code class="docutils literal notranslate"><span class="pre">let</span></code> statements inside multiclasses, providing
another way to factor out commonality from the records, especially when
using several levels of multiclass instantiations.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>multiclass basic_r &lt;bits&lt;4&gt; opc&gt; {
  let Predicates = [HasSSE2] in {
    def rr : Instruction&lt;opc, &quot;rr&quot;&gt;;
    def rm : Instruction&lt;opc, &quot;rm&quot;&gt;;
  }
  let Predicates = [HasSSE3] in
    def rx : Instruction&lt;opc, &quot;rx&quot;&gt;;
}

multiclass basic_ss &lt;bits&lt;4&gt; opc&gt; {
  let IsDouble = 0 in
    defm SS : basic_r&lt;opc&gt;;

  let IsDouble = 1 in
    defm SD : basic_r&lt;opc&gt;;
}

defm ADD : basic_ss&lt;0xf&gt;;
</pre></div>
</div>
</div>
<div class="section" id="defset-create-a-definition-set">
<h3><a class="toc-backref" href="#id23">1.6.8&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">defset</span></code> — create a definition set</a><a class="headerlink" href="#defset-create-a-definition-set" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">defset</span></code> statement is used to collect a set of records into a global
list of records.</p>
<pre>
<strong id="grammar-token-defset">Defset</strong> ::=  &quot;defset&quot; <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">Type</span></code></a> <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> &quot;=&quot; &quot;{&quot; <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>* &quot;}&quot;
</pre>
<p>All records defined inside the braces via <code class="docutils literal notranslate"><span class="pre">def</span></code> and <code class="docutils literal notranslate"><span class="pre">defm</span></code> are defined
as usual, and they are also collected in a global list of the given name
(<a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a>).</p>
<p>The specified type must be <code class="docutils literal notranslate"><span class="pre">list&lt;</span></code><em>class</em><code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, where <em>class</em> is some
record class.  The <code class="docutils literal notranslate"><span class="pre">defset</span></code> statement establishes a scope for its
statements. It is an error to define a record in the scope of the
<code class="docutils literal notranslate"><span class="pre">defset</span></code> that is not of type <em>class</em>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">defset</span></code> statement can be nested. The inner <code class="docutils literal notranslate"><span class="pre">defset</span></code> adds the
records to its own set, and all those records are also added to the outer
set.</p>
<p>Anonymous records created inside initialization expressions using the
<code class="docutils literal notranslate"><span class="pre">ClassID&lt;...&gt;</span></code> syntax are not collected in the set.</p>
</div>
<div class="section" id="defvar-define-a-variable">
<h3><a class="toc-backref" href="#id24">1.6.9&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">defvar</span></code> — define a variable</a><a class="headerlink" href="#defvar-define-a-variable" title="Permalink to this headline">¶</a></h3>
<p>A <code class="docutils literal notranslate"><span class="pre">defvar</span></code> statement defines a global variable. Its value can be used
throughout the statements that follow the definition.</p>
<pre>
<strong id="grammar-token-defvar">Defvar</strong> ::=  &quot;defvar&quot; <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> &quot;=&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> &quot;;&quot;
</pre>
<p>The identifier on the left of the <code class="docutils literal notranslate"><span class="pre">=</span></code> is defined to be a global variable
whose value is given by the value expression on the right of the <code class="docutils literal notranslate"><span class="pre">=</span></code>. The
type of the variable is automatically inferred.</p>
<p>Once a variable has been defined, it cannot be set to another value.</p>
<p>Variables defined in a top-level <code class="docutils literal notranslate"><span class="pre">foreach</span></code> go out of scope at the end of
each loop iteration, so their value in one iteration is not available in
the next iteration.  The following <code class="docutils literal notranslate"><span class="pre">defvar</span></code> will not work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>defvar i = !add(i, 1)
</pre></div>
</div>
<p>Variables can also be defined with <code class="docutils literal notranslate"><span class="pre">defvar</span></code> in a record body. See
<a class="reference internal" href="#defvar-in-a-record-body">Defvar in a Record Body</a> for more details.</p>
</div>
<div class="section" id="foreach-iterate-over-a-sequence-of-statements">
<h3><a class="toc-backref" href="#id25">1.6.10&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">foreach</span></code> — iterate over a sequence of statements</a><a class="headerlink" href="#foreach-iterate-over-a-sequence-of-statements" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">foreach</span></code> statement iterates over a series of statements, varying a
variable over a sequence of values.</p>
<pre>
<strong id="grammar-token-foreach">Foreach        </strong> ::=  &quot;foreach&quot; <a class="reference internal" href="#grammar-token-foreachiterator"><code class="xref docutils literal notranslate"><span class="pre">ForeachIterator</span></code></a> &quot;in&quot; &quot;{&quot; <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>* &quot;}&quot;
                    | &quot;foreach&quot; <a class="reference internal" href="#grammar-token-foreachiterator"><code class="xref docutils literal notranslate"><span class="pre">ForeachIterator</span></code></a> &quot;in&quot; <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>
<strong id="grammar-token-foreachiterator">ForeachIterator</strong> ::=  <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> &quot;=&quot; (&quot;{&quot; <a class="reference internal" href="#grammar-token-rangelist"><code class="xref docutils literal notranslate"><span class="pre">RangeList</span></code></a> &quot;}&quot; | <a class="reference internal" href="#grammar-token-rangepiece"><code class="xref docutils literal notranslate"><span class="pre">RangePiece</span></code></a> | <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a>)
</pre>
<p>The body of the <code class="docutils literal notranslate"><span class="pre">foreach</span></code> is a series of statements in braces or a
single statement with no braces. The statements are re-evaluated once for
each value in the range list, range piece, or single value. On each
iteration, the <a class="reference internal" href="#grammar-token-tokidentifier"><code class="xref std std-token docutils literal notranslate"><span class="pre">TokIdentifier</span></code></a> variable is set to the value and can
be used in the statements.</p>
<p>The statement list establishes an inner scope. Variables local to a
<code class="docutils literal notranslate"><span class="pre">foreach</span></code> go out of scope at the end of each loop iteration, so their
values do not carry over from one iteration to the next. Foreach loops may
be nested.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">foreach</span></code> statement can also be used in a record <a class="reference internal" href="#grammar-token-body"><code class="xref std std-token docutils literal notranslate"><span class="pre">Body</span></code></a>.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>foreach i = [0, 1, 2, 3] in {
  def R#i : Register&lt;...&gt;;
  def F#i : Register&lt;...&gt;;
}
</pre></div>
</div>
<p>This loop defines records named <code class="docutils literal notranslate"><span class="pre">R0</span></code>, <code class="docutils literal notranslate"><span class="pre">R1</span></code>, <code class="docutils literal notranslate"><span class="pre">R2</span></code>, and <code class="docutils literal notranslate"><span class="pre">R3</span></code>, along
with <code class="docutils literal notranslate"><span class="pre">F0</span></code>, <code class="docutils literal notranslate"><span class="pre">F1</span></code>, <code class="docutils literal notranslate"><span class="pre">F2</span></code>, and <code class="docutils literal notranslate"><span class="pre">F3</span></code>.</p>
</div>
<div class="section" id="if-select-statements-based-on-a-test">
<h3><a class="toc-backref" href="#id26">1.6.11&nbsp;&nbsp;&nbsp;<code class="docutils literal notranslate"><span class="pre">if</span></code> — select statements based on a test</a><a class="headerlink" href="#if-select-statements-based-on-a-test" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">if</span></code> statement allows one of two statement groups to be selected based
on the value of an expression.</p>
<pre>
<strong id="grammar-token-if">If    </strong> ::=  &quot;if&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> &quot;then&quot; <a class="reference internal" href="#grammar-token-ifbody"><code class="xref docutils literal notranslate"><span class="pre">IfBody</span></code></a>
           | &quot;if&quot; <a class="reference internal" href="#grammar-token-value"><code class="xref docutils literal notranslate"><span class="pre">Value</span></code></a> &quot;then&quot; <a class="reference internal" href="#grammar-token-ifbody"><code class="xref docutils literal notranslate"><span class="pre">IfBody</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-ifbody"><code class="xref docutils literal notranslate"><span class="pre">IfBody</span></code></a>
<strong id="grammar-token-ifbody">IfBody</strong> ::=  &quot;{&quot; <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>* &quot;}&quot; | <a class="reference internal" href="#grammar-token-statement"><code class="xref docutils literal notranslate"><span class="pre">Statement</span></code></a>
</pre>
<p>The value expression is evaluated. If it evaluates to true (in the same
sense used by the bang operators), then the statements following the
<code class="docutils literal notranslate"><span class="pre">then</span></code> reserved word are processed. Otherwise, if there is an <code class="docutils literal notranslate"><span class="pre">else</span></code>
reserved word, the statements following the <code class="docutils literal notranslate"><span class="pre">else</span></code> are processed. If the
value is false and there is no <code class="docutils literal notranslate"><span class="pre">else</span></code> arm, no statements are processed.</p>
<p>Because the braces around the <code class="docutils literal notranslate"><span class="pre">then</span></code> statements are optional, this grammar rule
has the usual ambiguity with “dangling else” clauses, and it is resolved in
the usual way: in a case like <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">v1</span> <span class="pre">then</span> <span class="pre">if</span> <span class="pre">v2</span> <span class="pre">then</span> <span class="pre">{...}</span> <span class="pre">else</span> <span class="pre">{...}</span></code>, the
<code class="docutils literal notranslate"><span class="pre">else</span></code> associates with the inner <code class="docutils literal notranslate"><span class="pre">if</span></code> rather than the outer one.</p>
<p>The <a class="reference internal" href="#grammar-token-ifbody"><code class="xref std std-token docutils literal notranslate"><span class="pre">IfBody</span></code></a> of the then and else arms of the <code class="docutils literal notranslate"><span class="pre">if</span></code> establish an
inner scope. Any <code class="docutils literal notranslate"><span class="pre">defvar</span></code> variables defined in the bodies go out of scope
when the bodies are finished (see <a class="reference internal" href="#defvar-in-a-record-body">Defvar in a Record Body</a> for more details).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">if</span></code> statement can also be used in a record <a class="reference internal" href="#grammar-token-body"><code class="xref std std-token docutils literal notranslate"><span class="pre">Body</span></code></a>.</p>
</div>
</div>
<div class="section" id="additional-details">
<h2><a class="toc-backref" href="#id27">1.7&nbsp;&nbsp;&nbsp;Additional Details</a><a class="headerlink" href="#additional-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="directed-acyclic-graphs-dags">
<h3><a class="toc-backref" href="#id28">1.7.1&nbsp;&nbsp;&nbsp;Directed acyclic graphs (DAGs)</a><a class="headerlink" href="#directed-acyclic-graphs-dags" title="Permalink to this headline">¶</a></h3>
<p>A directed acyclic graph can be represented directly in TableGen using the
<code class="docutils literal notranslate"><span class="pre">dag</span></code> datatype. A DAG node consists of an operator and zero or more
arguments (or operands). Each argument can be of any desired type. By using
another DAG node as an argument, an arbitrary graph of DAG nodes can be
built.</p>
<p>The syntax of a <code class="docutils literal notranslate"><span class="pre">dag</span></code> instance is:</p>
<blockquote>
<div><code class="docutils literal notranslate"><span class="pre">(</span></code> <em>operator</em> <em>argument1</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>argument2</em><code class="docutils literal notranslate"><span class="pre">,</span></code> … <code class="docutils literal notranslate"><span class="pre">)</span></code></div></blockquote>
<p>The operator must be present and must be a record. There can be zero or more
arguments, separated by commas. The operator and arguments can have three
formats.</p>
<table border="1" class="docutils">
<colgroup>
<col width="32%" />
<col width="68%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Format</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><em>value</em></td>
<td>argument value</td>
</tr>
<tr class="row-odd"><td><em>value</em><code class="docutils literal notranslate"><span class="pre">:</span></code><em>name</em></td>
<td>argument value and associated name</td>
</tr>
<tr class="row-even"><td><em>name</em></td>
<td>argument name with unset (uninitialized) value</td>
</tr>
</tbody>
</table>
<p>The <em>value</em> can be any TableGen value. The <em>name</em>, if present, must be a
<a class="reference internal" href="#grammar-token-tokvarname"><code class="xref std std-token docutils literal notranslate"><span class="pre">TokVarName</span></code></a>, which starts with a dollar sign (<code class="docutils literal notranslate"><span class="pre">$</span></code>). The purpose of
a name is to tag an operator or argument in a DAG with a particular meaning,
or to associate an argument in one DAG with a like-named argument in another
DAG.</p>
<p>The following bang operators are useful for working with DAGs:
<code class="docutils literal notranslate"><span class="pre">!con</span></code>, <code class="docutils literal notranslate"><span class="pre">!dag</span></code>, <code class="docutils literal notranslate"><span class="pre">!empty</span></code>, <code class="docutils literal notranslate"><span class="pre">!foreach</span></code>, <code class="docutils literal notranslate"><span class="pre">!getdagop</span></code>, <code class="docutils literal notranslate"><span class="pre">!setdagop</span></code>, <code class="docutils literal notranslate"><span class="pre">!size</span></code>.</p>
</div>
<div class="section" id="defvar-in-a-record-body">
<h3><a class="toc-backref" href="#id29">1.7.2&nbsp;&nbsp;&nbsp;Defvar in a record body</a><a class="headerlink" href="#defvar-in-a-record-body" title="Permalink to this headline">¶</a></h3>
<p>In addition to defining global variables, the <code class="docutils literal notranslate"><span class="pre">defvar</span></code> statement can
be used inside the <a class="reference internal" href="#grammar-token-body"><code class="xref std std-token docutils literal notranslate"><span class="pre">Body</span></code></a> of a class or record definition to define
local variables. The scope of the variable extends from the <code class="docutils literal notranslate"><span class="pre">defvar</span></code>
statement to the end of the body. It cannot be set to a different value
within its scope. The <code class="docutils literal notranslate"><span class="pre">defvar</span></code> statement can also be used in the statement
list of a <code class="docutils literal notranslate"><span class="pre">foreach</span></code>, which establishes a scope.</p>
<p>A variable named <code class="docutils literal notranslate"><span class="pre">V</span></code> in an inner scope shadows (hides) any variables <code class="docutils literal notranslate"><span class="pre">V</span></code>
in outer scopes. In particular, <code class="docutils literal notranslate"><span class="pre">V</span></code> in a record body shadows a global
<code class="docutils literal notranslate"><span class="pre">V</span></code>, and <code class="docutils literal notranslate"><span class="pre">V</span></code> in a <code class="docutils literal notranslate"><span class="pre">foreach</span></code> statement list shadows any <code class="docutils literal notranslate"><span class="pre">V</span></code> in
surrounding record or global scopes.</p>
<p>Variables defined in a <code class="docutils literal notranslate"><span class="pre">foreach</span></code> go out of scope at the end of
each loop iteration, so their value in one iteration is not available in
the next iteration.  The following <code class="docutils literal notranslate"><span class="pre">defvar</span></code> will not work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>defvar i = !add(i, 1)
</pre></div>
</div>
</div>
<div class="section" id="how-records-are-built">
<h3><a class="toc-backref" href="#id30">1.7.3&nbsp;&nbsp;&nbsp;How records are built</a><a class="headerlink" href="#how-records-are-built" title="Permalink to this headline">¶</a></h3>
<p>The following steps are taken by TableGen when a record is built. Classes are simply
abstract records and so go through the same steps.</p>
<ol class="arabic simple">
<li>Build the record name (<a class="reference internal" href="#grammar-token-namevalue"><code class="xref std std-token docutils literal notranslate"><span class="pre">NameValue</span></code></a>) and create an empty record.</li>
<li>Parse the superclasses in the <a class="reference internal" href="#grammar-token-parentclasslist"><code class="xref std std-token docutils literal notranslate"><span class="pre">ParentClassList</span></code></a> from left to
right, visiting each superclass’s ancestor classes from top to bottom.</li>
</ol>
<blockquote>
<div><ol class="loweralpha simple">
<li>Add the fields from the superclass to the record.</li>
<li>Substitute the template arguments into those fields.</li>
<li>Add the superclass to the record’s list of inherited classes.</li>
</ol>
</div></blockquote>
<ol class="arabic simple" start="3">
<li>Apply any top-level <code class="docutils literal notranslate"><span class="pre">let</span></code> bindings to the record. Recall that top-level
bindings only apply to inherited fields.</li>
<li>Parse the body of the record.</li>
</ol>
<blockquote>
<div><ul class="simple">
<li>Add any fields to the record.</li>
<li>Modify the values of fields according to local <code class="docutils literal notranslate"><span class="pre">let</span></code> statements.</li>
<li>Define any <code class="docutils literal notranslate"><span class="pre">defvar</span></code> variables.</li>
</ul>
</div></blockquote>
<ol class="arabic simple" start="5">
<li>Make a pass over all the fields to resolve any inter-field references.</li>
<li>Add the record to the master record list.</li>
</ol>
<p>Because references between fields are resolved (step 5) after <code class="docutils literal notranslate"><span class="pre">let</span></code> bindings are
applied (step 3), the <code class="docutils literal notranslate"><span class="pre">let</span></code> statement has unusual power. For example:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class C &lt;int x&gt; {
  int Y = x;
  int Yplus1 = !add(Y, 1);
  int xplus1 = !add(x, 1);
}

let Y = 10 in {
  def rec1 : C&lt;5&gt; {
  }
}

def rec2 : C&lt;5&gt; {
  let Y = 10;
}
</pre></div>
</div>
<p>In both cases, one where a top-level <code class="docutils literal notranslate"><span class="pre">let</span></code> is used to bind <code class="docutils literal notranslate"><span class="pre">Y</span></code> and one
where a local <code class="docutils literal notranslate"><span class="pre">let</span></code> does the same thing, the results are:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def rec1 {      // C
  int Y = 10;
  int Yplus1 = 11;
  int xplus1 = 6;
}
def rec2 {      // C
  int Y = 10;
  int Yplus1 = 11;
  int xplus1 = 6;
}
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">Yplus1</span></code> is 11 because the <code class="docutils literal notranslate"><span class="pre">let</span> <span class="pre">Y</span></code> is performed before the <code class="docutils literal notranslate"><span class="pre">!add(Y,</span>
<span class="pre">1)</span></code> is resolved. Use this power wisely.</p>
</div>
</div>
<div class="section" id="using-classes-as-subroutines">
<h2><a class="toc-backref" href="#id31">1.8&nbsp;&nbsp;&nbsp;Using Classes as Subroutines</a><a class="headerlink" href="#using-classes-as-subroutines" title="Permalink to this headline">¶</a></h2>
<p>As described in <a class="reference internal" href="#simple-values">Simple values</a>, a class can be invoked in an expression
and passed template arguments. This causes TableGen to create a new anonymous
record inheriting from that class. As usual, the record receives all the
fields defined in the class.</p>
<p>This feature can be employed as a simple subroutine facility. The class can
use the template arguments to define various variables and fields, which end
up in the anonymous record. Those fields can then be retrieved in the
expression invoking the class as follows. Assume that the field <code class="docutils literal notranslate"><span class="pre">ret</span></code>
contains the final value of the subroutine.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>int Result = ... CalcValue&lt;arg&gt;.ret ...;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">CalcValue</span></code> class is invoked with the template argument <code class="docutils literal notranslate"><span class="pre">arg</span></code>. It
calculates a value for the <code class="docutils literal notranslate"><span class="pre">ret</span></code> field, which is then retrieved at the
“point of call” in the initialization for the Result field. The anonymous
record created in this example serves no other purpose than to carry the
result value.</p>
<p>Here is a practical example. The class <code class="docutils literal notranslate"><span class="pre">isValidSize</span></code> determines whether a
specified number of bytes represents a valid data size. The bit <code class="docutils literal notranslate"><span class="pre">ret</span></code> is
set appropriately. The field <code class="docutils literal notranslate"><span class="pre">ValidSize</span></code> obtains its initial value by
invoking <code class="docutils literal notranslate"><span class="pre">isValidSize</span></code> with the data size and retrieving the <code class="docutils literal notranslate"><span class="pre">ret</span></code> field
from the resulting anonymous record.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>class isValidSize&lt;int size&gt; {
  bit ret = !cond(!eq(size,  1): 1,
                  !eq(size,  2): 1,
                  !eq(size,  4): 1,
                  !eq(size,  8): 1,
                  !eq(size, 16): 1,
                  1: 0);
}

def Data1 {
  int Size = ...;
  bit ValidSize = isValidSize&lt;Size&gt;.ret;
}
</pre></div>
</div>
</div>
<div class="section" id="preprocessing-facilities">
<h2><a class="toc-backref" href="#id32">1.9&nbsp;&nbsp;&nbsp;Preprocessing Facilities</a><a class="headerlink" href="#preprocessing-facilities" title="Permalink to this headline">¶</a></h2>
<p>The preprocessor embedded in TableGen is intended only for simple
conditional compilation. It supports the following directives, which are
specified somewhat informally.</p>
<pre>
<strong id="grammar-token-linebegin">LineBegin             </strong> ::=  beginning of line
<strong id="grammar-token-lineend">LineEnd               </strong> ::=  newline | return | EOF
<strong id="grammar-token-whitespace">WhiteSpace            </strong> ::=  space | tab
<strong id="grammar-token-ccomment">CComment              </strong> ::=  &quot;/*&quot; ... &quot;*/&quot;
<strong id="grammar-token-bcplcomment">BCPLComment           </strong> ::=  &quot;//&quot; ... <a class="reference internal" href="#grammar-token-lineend"><code class="xref docutils literal notranslate"><span class="pre">LineEnd</span></code></a>
<strong id="grammar-token-whitespaceorccomment">WhiteSpaceOrCComment  </strong> ::=  <a class="reference internal" href="#grammar-token-whitespace"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpace</span></code></a> | <a class="reference internal" href="#grammar-token-ccomment"><code class="xref docutils literal notranslate"><span class="pre">CComment</span></code></a>
<strong id="grammar-token-whitespaceoranycomment">WhiteSpaceOrAnyComment</strong> ::=  <a class="reference internal" href="#grammar-token-whitespace"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpace</span></code></a> | <a class="reference internal" href="#grammar-token-ccomment"><code class="xref docutils literal notranslate"><span class="pre">CComment</span></code></a> | <a class="reference internal" href="#grammar-token-bcplcomment"><code class="xref docutils literal notranslate"><span class="pre">BCPLComment</span></code></a>
<strong id="grammar-token-macroname">MacroName             </strong> ::=  <a class="reference internal" href="#grammar-token-ualpha"><code class="xref docutils literal notranslate"><span class="pre">ualpha</span></code></a> (<a class="reference internal" href="#grammar-token-ualpha"><code class="xref docutils literal notranslate"><span class="pre">ualpha</span></code></a> | &quot;0&quot;...&quot;9&quot;)*
<strong id="grammar-token-predefine">PreDefine             </strong> ::=  <a class="reference internal" href="#grammar-token-linebegin"><code class="xref docutils literal notranslate"><span class="pre">LineBegin</span></code></a> (<a class="reference internal" href="#grammar-token-whitespaceorccomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrCComment</span></code></a>)*
                            &quot;#define&quot; (<a class="reference internal" href="#grammar-token-whitespace"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpace</span></code></a>)+ <a class="reference internal" href="#grammar-token-macroname"><code class="xref docutils literal notranslate"><span class="pre">MacroName</span></code></a>
                            (<a class="reference internal" href="#grammar-token-whitespaceoranycomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrAnyComment</span></code></a>)* <a class="reference internal" href="#grammar-token-lineend"><code class="xref docutils literal notranslate"><span class="pre">LineEnd</span></code></a>
<strong id="grammar-token-preifdef">PreIfdef              </strong> ::=  <a class="reference internal" href="#grammar-token-linebegin"><code class="xref docutils literal notranslate"><span class="pre">LineBegin</span></code></a> (<a class="reference internal" href="#grammar-token-whitespaceorccomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrCComment</span></code></a>)*
                            (&quot;#ifdef&quot; | &quot;#ifndef&quot;) (<a class="reference internal" href="#grammar-token-whitespace"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpace</span></code></a>)+ <a class="reference internal" href="#grammar-token-macroname"><code class="xref docutils literal notranslate"><span class="pre">MacroName</span></code></a>
                            (<a class="reference internal" href="#grammar-token-whitespaceoranycomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrAnyComment</span></code></a>)* <a class="reference internal" href="#grammar-token-lineend"><code class="xref docutils literal notranslate"><span class="pre">LineEnd</span></code></a>
<strong id="grammar-token-preelse">PreElse               </strong> ::=  <a class="reference internal" href="#grammar-token-linebegin"><code class="xref docutils literal notranslate"><span class="pre">LineBegin</span></code></a> (<a class="reference internal" href="#grammar-token-whitespaceorccomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrCComment</span></code></a>)*
                            &quot;#else&quot; (<a class="reference internal" href="#grammar-token-whitespaceoranycomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrAnyComment</span></code></a>)* <a class="reference internal" href="#grammar-token-lineend"><code class="xref docutils literal notranslate"><span class="pre">LineEnd</span></code></a>
<strong id="grammar-token-preendif">PreEndif              </strong> ::=  <a class="reference internal" href="#grammar-token-linebegin"><code class="xref docutils literal notranslate"><span class="pre">LineBegin</span></code></a> (<a class="reference internal" href="#grammar-token-whitespaceorccomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrCComment</span></code></a>)*
                            &quot;#endif&quot; (<a class="reference internal" href="#grammar-token-whitespaceoranycomment"><code class="xref docutils literal notranslate"><span class="pre">WhiteSpaceOrAnyComment</span></code></a>)* <a class="reference internal" href="#grammar-token-lineend"><code class="xref docutils literal notranslate"><span class="pre">LineEnd</span></code></a>
</pre>
<p>A <a class="reference internal" href="#grammar-token-macroname"><code class="xref std std-token docutils literal notranslate"><span class="pre">MacroName</span></code></a> can be defined anywhere in a TableGen file. The name has
no value; it can only be tested to see whether it is defined.</p>
<p>A macro test region begins with an <code class="docutils literal notranslate"><span class="pre">#ifdef</span></code> or <code class="docutils literal notranslate"><span class="pre">#ifndef</span></code> directive. If
the macro name is defined (<code class="docutils literal notranslate"><span class="pre">#ifdef</span></code>) or undefined (<code class="docutils literal notranslate"><span class="pre">#ifndef</span></code>), then the
source code between the directive and the corresponding <code class="docutils literal notranslate"><span class="pre">#else</span></code> or
<code class="docutils literal notranslate"><span class="pre">#endif</span></code> is processed. If the test fails but there is an <code class="docutils literal notranslate"><span class="pre">#else</span></code>
clause, the source code between the <code class="docutils literal notranslate"><span class="pre">#else</span></code> and the <code class="docutils literal notranslate"><span class="pre">#endif</span></code> is
processed. If the test fails and there is no <code class="docutils literal notranslate"><span class="pre">#else</span></code> clause, then no
source code in the test region is processed.</p>
<p>Test regions may be nested, but they must be properly nested. A region
started in a file must end in that file; that is, must have its
<code class="docutils literal notranslate"><span class="pre">#endif</span></code> in the same file.</p>
<p>A <a class="reference internal" href="#grammar-token-macroname"><code class="xref std std-token docutils literal notranslate"><span class="pre">MacroName</span></code></a> may be defined externally using the <code class="docutils literal notranslate"><span class="pre">-D</span></code> option on the
<code class="docutils literal notranslate"><span class="pre">xxx-tblgen</span></code> command line:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">llvm</span><span class="o">-</span><span class="n">tblgen</span> <span class="bp">self</span><span class="o">-</span><span class="n">reference</span><span class="o">.</span><span class="n">td</span> <span class="o">-</span><span class="n">Dmacro1</span> <span class="o">-</span><span class="n">Dmacro3</span>
</pre></div>
</div>
</div>
<div class="section" id="appendix-a-bang-operators">
<h2><a class="toc-backref" href="#id33">1.10&nbsp;&nbsp;&nbsp;Appendix A: Bang Operators</a><a class="headerlink" href="#appendix-a-bang-operators" title="Permalink to this headline">¶</a></h2>
<p>Bang operators act as functions in value expressions. A bang operator takes
one or more arguments, operates on them, and produces a result. If the
operator produces a boolean result, the result value will be 1 for true or 0
for false. When an operator tests a boolean argument, it interprets 0 as false
and non-0 as true.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">!getop</span></code> and <code class="docutils literal notranslate"><span class="pre">!setop</span></code> bang operators are deprecated in favor of
<code class="docutils literal notranslate"><span class="pre">!getdagop</span></code> and <code class="docutils literal notranslate"><span class="pre">!setdagop</span></code>.</p>
</div>
<dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">!add(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd>This operator adds <em>a</em>, <em>b</em>, etc., and produces the sum.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!and(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd>This operator does a bitwise AND on <em>a</em>, <em>b</em>, etc., and produces the
result. A logical AND can be performed if all the arguments are either
0 or 1.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!cast&lt;</span></code><em>type</em><code class="docutils literal notranslate"><span class="pre">&gt;(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd><p class="first">This operator performs a cast on <em>a</em> and produces the result.
If <em>a</em> is not a string, then a straightforward cast is performed, say
between an <code class="docutils literal notranslate"><span class="pre">int</span></code> and a <code class="docutils literal notranslate"><span class="pre">bit</span></code>, or between record types. This allows
casting a record to a class. If a record is cast to <code class="docutils literal notranslate"><span class="pre">string</span></code>, the
record’s name is produced.</p>
<p>If <em>a</em> is a string, then it is treated as a record name and looked up in
the list of all defined records. The resulting record is expected to be of
the specified <em>type</em>.</p>
<p>For example, if <code class="docutils literal notranslate"><span class="pre">!cast&lt;</span></code><em>type</em><code class="docutils literal notranslate"><span class="pre">&gt;(</span></code><em>name</em><code class="docutils literal notranslate"><span class="pre">)</span></code>
appears in a multiclass definition, or in a
class instantiated inside a multiclass definition, and the <em>name</em> does not
reference any template arguments of the multiclass, then a record by
that name must have been instantiated earlier
in the source file. If <em>name</em> does reference
a template argument, then the lookup is delayed until <code class="docutils literal notranslate"><span class="pre">defm</span></code> statements
instantiating the multiclass (or later, if the defm occurs in another
multiclass and template arguments of the inner multiclass that are
referenced by <em>name</em> are substituted by values that themselves contain
references to template arguments of the outer multiclass).</p>
<p class="last">If the type of <em>a</em> does not match <em>type</em>, TableGen raises an error.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!con(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd><p class="first">This operator concatenates the DAG nodes <em>a</em>, <em>b</em>, etc. Their operations
must equal.</p>
<p><code class="docutils literal notranslate"><span class="pre">!con((op</span> <span class="pre">a1:$name1,</span> <span class="pre">a2:$name2),</span> <span class="pre">(op</span> <span class="pre">b1:$name3))</span></code></p>
<p class="last">results in the DAG node <code class="docutils literal notranslate"><span class="pre">(op</span> <span class="pre">a1:$name1,</span> <span class="pre">a2:$name2,</span> <span class="pre">b1:$name3)</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!cond(</span></code><em>cond1</em> <code class="docutils literal notranslate"><span class="pre">:</span></code> <em>val1</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>cond2</em> <code class="docutils literal notranslate"><span class="pre">:</span></code> <em>val2</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...,</span></code> <em>condn</em> <code class="docutils literal notranslate"><span class="pre">:</span></code> <em>valn</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd><p class="first">This operator tests <em>cond1</em> and returns <em>val1</em> if the result is true.
If false, the operator tests <em>cond2</em> and returns <em>val2</em> if the result is
true. And so forth. An error is reported if no conditions are true.</p>
<p>This example produces the sign word for an integer:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span>!cond(!lt(x, 0) : &quot;negative&quot;, !eq(x, 0) : &quot;zero&quot;, 1 : &quot;positive&quot;)
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!dag(</span></code><em>op</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>children</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>names</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd><p class="first">This operator creates a DAG node.
The <em>children</em> and <em>names</em> arguments must be lists
of equal length or uninitialized (<code class="docutils literal notranslate"><span class="pre">?</span></code>). The <em>names</em> argument
must be of type <code class="docutils literal notranslate"><span class="pre">list&lt;string&gt;</span></code>.</p>
<p>Due to limitations of the type system, <em>children</em> must be a list of items
of a common type. In practice, this means that they should either have the
same type or be records with a common superclass. Mixing <code class="docutils literal notranslate"><span class="pre">dag</span></code> and
non-<code class="docutils literal notranslate"><span class="pre">dag</span></code> items is not possible. However, <code class="docutils literal notranslate"><span class="pre">?</span></code> can be used.</p>
<p class="last">Example: <code class="docutils literal notranslate"><span class="pre">!dag(op,</span> <span class="pre">[a1,</span> <span class="pre">a2,</span> <span class="pre">?],</span> <span class="pre">[&quot;name1&quot;,</span> <span class="pre">&quot;name2&quot;,</span> <span class="pre">&quot;name3&quot;])</span></code> results in
<code class="docutils literal notranslate"><span class="pre">(op</span> <span class="pre">a1:$name1,</span> <span class="pre">a2:$name2,</span> <span class="pre">?:$name3)</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!empty(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if the string, list, or DAG <em>a</em> is empty; 0 otherwise.
A dag is empty if it has no arguments; the operator does not count.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!eq(</span></code> <em>a</em><cite>,</cite> <em>b</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if <em>a</em> is equal to <em>b</em>; 0 otherwise.
The arguments must be <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, or <code class="docutils literal notranslate"><span class="pre">string</span></code> values.
Use <code class="docutils literal notranslate"><span class="pre">!cast&lt;string&gt;</span></code> to compare other types of objects.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!foldl(</span></code><em>start</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>list</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>expr</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd><p class="first">This operator performs a left-fold over the items in <em>list</em>. The
variable <em>a</em> acts as the accumulator and is initialized to <em>start</em>.
The variable <em>b</em> is bound to each element in the <em>list</em>. The <em>expr</em>
expression is evaluated for each element and presumably uses <em>a</em> and <em>b</em>
to calculate the accumulated value, which <code class="docutils literal notranslate"><span class="pre">!foldl</span></code> stores in <em>a</em>. The
type of <em>a</em> is the same as <em>start</em>; the type of <em>b</em> is the same as the
elements of <em>list</em>; <em>expr</em> must have the same type as <em>start</em>.</p>
<p>The following example computes the total of the <code class="docutils literal notranslate"><span class="pre">Number</span></code> field in the
list of records in <code class="docutils literal notranslate"><span class="pre">RecList</span></code>:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span>int x = !foldl(0, RecList, total, rec, !add(total, rec.Number));
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!foreach(</span></code><em>var</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>seq</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>form</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator creates a new <code class="docutils literal notranslate"><span class="pre">list</span></code>/<code class="docutils literal notranslate"><span class="pre">dag</span></code> in which each element is a
function of the corresponding element in the <em>seq</em> <code class="docutils literal notranslate"><span class="pre">list</span></code>/<code class="docutils literal notranslate"><span class="pre">dag</span></code>. To
perform the function, TableGen binds the variable <em>var</em> to an element and
then evaluates the <em>form</em> expression. The form presumably refers to the
variable <em>var</em> and calculates the result value.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!ge(</span></code><em>a</em><cite>,</cite> <em>b</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if <em>a</em> is greater than or equal to <em>b</em>; 0 otherwise.
The arguments must be <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, or <code class="docutils literal notranslate"><span class="pre">string</span></code> values.
Use <code class="docutils literal notranslate"><span class="pre">!cast&lt;string&gt;</span></code> to compare other types of objects.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!getdagop(</span></code><em>dag</em><code class="docutils literal notranslate"><span class="pre">)</span></code> –or– <code class="docutils literal notranslate"><span class="pre">!getdagop&lt;</span></code><em>type</em><code class="docutils literal notranslate"><span class="pre">&gt;(</span></code><em>dag</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd><p class="first">This operator produces the operator of the given <em>dag</em> node.
Example: <code class="docutils literal notranslate"><span class="pre">!getdagop((foo</span> <span class="pre">1,</span> <span class="pre">2))</span></code> results in <code class="docutils literal notranslate"><span class="pre">foo</span></code>. Recall that
DAG operators are always records.</p>
<p>The result of <code class="docutils literal notranslate"><span class="pre">!getdagop</span></code> can be used directly in a context where
any record class at all is acceptable (typically placing it into
another dag value). But in other contexts, it must be explicitly
cast to a particular class. The <code class="docutils literal notranslate"><span class="pre">&lt;</span></code><em>type</em><code class="docutils literal notranslate"><span class="pre">&gt;</span></code> syntax is
provided to make this easy.</p>
<p>For example, to assign the result to a value of type <code class="docutils literal notranslate"><span class="pre">BaseClass</span></code>, you
could write either of these:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>BaseClass b = !getdagop&lt;BaseClass&gt;(someDag);
BaseClass b = !cast&lt;BaseClass&gt;(!getdagop(someDag));
</pre></div>
</div>
<p>But to create a new DAG node that reuses the operator from another, no
cast is necessary:</p>
<div class="last highlight-default notranslate"><div class="highlight"><pre><span></span>dag d = !dag(!getdagop(someDag), args, names);
</pre></div>
</div>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!gt(</span></code><em>a</em><cite>,</cite> <em>b</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if <em>a</em> is greater than <em>b</em>; 0 otherwise.
The arguments must be <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, or <code class="docutils literal notranslate"><span class="pre">string</span></code> values.
Use <code class="docutils literal notranslate"><span class="pre">!cast&lt;string&gt;</span></code> to compare other types of objects.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!head(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces the zeroth element of the list <em>a</em>.
(See also <code class="docutils literal notranslate"><span class="pre">!tail</span></code>.)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!if(</span></code><em>test</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>then</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>else</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator evaluates the <em>test</em>, which must produce a <code class="docutils literal notranslate"><span class="pre">bit</span></code> or
<code class="docutils literal notranslate"><span class="pre">int</span></code>. If the result is not 0, the <em>then</em> expression is produced; otherwise
the <em>else</em> expression is produced.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!isa&lt;</span></code><em>type</em><code class="docutils literal notranslate"><span class="pre">&gt;(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if the type of <em>a</em> is a subtype of the given <em>type</em>; 0
otherwise.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!le(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if <em>a</em> is less than or equal to <em>b</em>; 0 otherwise.
The arguments must be <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, or <code class="docutils literal notranslate"><span class="pre">string</span></code> values.
Use <code class="docutils literal notranslate"><span class="pre">!cast&lt;string&gt;</span></code> to compare other types of objects.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!listconcat(</span></code><em>list1</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>list2</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd>This operator concatenates the list arguments <em>list1</em>, <em>list2</em>, etc., and
produces the resulting list. The lists must have the same element type.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!listsplat(</span></code><em>value</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>count</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces a list of length <em>count</em> whose elements are all
equal to the <em>value</em>. For example, <code class="docutils literal notranslate"><span class="pre">!listsplat(42,</span> <span class="pre">3)</span></code> results in
<code class="docutils literal notranslate"><span class="pre">[42,</span> <span class="pre">42,</span> <span class="pre">42]</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!lt(</span></code><em>a</em><cite>,</cite> <em>b</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if <em>a</em> is less than <em>b</em>; 0 otherwise.
The arguments must be <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, or <code class="docutils literal notranslate"><span class="pre">string</span></code> values.
Use <code class="docutils literal notranslate"><span class="pre">!cast&lt;string&gt;</span></code> to compare other types of objects.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!mul(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd>This operator multiplies <em>a</em>, <em>b</em>, etc., and produces the product.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!ne(</span></code><em>a</em><cite>,</cite> <em>b</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces 1 if <em>a</em> is not equal to <em>b</em>; 0 otherwise.
The arguments must be <code class="docutils literal notranslate"><span class="pre">bit</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, or <code class="docutils literal notranslate"><span class="pre">string</span></code> values.
Use <code class="docutils literal notranslate"><span class="pre">!cast&lt;string&gt;</span></code> to compare other types of objects.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!not(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator performs a logical NOT on <em>a</em>, which must be
an integer. The argument 0 results in 1 (true); any other
argument results in 0 (false).</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!or(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd>This operator does a bitwise OR on <em>a</em>, <em>b</em>, etc., and produces the
result. A logical OR can be performed if all the arguments are either
0 or 1.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!setdagop(</span></code><em>dag</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>op</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd><p class="first">This operator produces a DAG node with the same arguments as <em>dag</em>, but with its
operator replaced with <em>op</em>.</p>
<p class="last">Example: <code class="docutils literal notranslate"><span class="pre">!setdagop((foo</span> <span class="pre">1,</span> <span class="pre">2),</span> <span class="pre">bar)</span></code> results in <code class="docutils literal notranslate"><span class="pre">(bar</span> <span class="pre">1,</span> <span class="pre">2)</span></code>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!shl(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>count</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator shifts <em>a</em> left logically by <em>count</em> bits and produces the resulting
value. The operation is performed on a 64-bit integer; the result
is undefined for shift counts outside 0…63.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!size(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces the size of the string, list, or dag <em>a</em>.
The size of a DAG is the number of arguments; the operator does not count.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!sra(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>count</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator shifts <em>a</em> right arithmetically by <em>count</em> bits and produces the resulting
value. The operation is performed on a 64-bit integer; the result
is undefined for shift counts outside 0…63.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!srl(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>count</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator shifts <em>a</em> right logically by <em>count</em> bits and produces the resulting
value. The operation is performed on a 64-bit integer; the result
is undefined for shift counts outside 0…63.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!strconcat(</span></code><em>str1</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>str2</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd>This operator concatenates the string arguments <em>str1</em>, <em>str2</em>, etc., and
produces the resulting string.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!sub(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator subtracts <em>b</em> from <em>a</em> and produces the arithmetic difference.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!subst(</span></code><em>target</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>repl</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>value</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd><p class="first">This operator replaces all occurrences of the <em>target</em> in the <em>value</em> with
the <em>repl</em> and produces the resulting value. The <em>value</em> can
be a string, in which case substring substitution is performed.</p>
<p class="last">The <em>value</em> can be a record name, in which case the operator produces the <em>repl</em>
record if the <em>target</em> record name equals the <em>value</em> record name; otherwise it
produces the <em>value</em>.</p>
</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!tail(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">)</span></code></dt>
<dd>This operator produces a new list with all the elements
of the list <em>a</em> except for the zeroth one. (See also <code class="docutils literal notranslate"><span class="pre">!head</span></code>.)</dd>
<dt><code class="docutils literal notranslate"><span class="pre">!xor(</span></code><em>a</em><code class="docutils literal notranslate"><span class="pre">,</span></code> <em>b</em><code class="docutils literal notranslate"><span class="pre">,</span> <span class="pre">...)</span></code></dt>
<dd>This operator does a bitwise EXCLUSIVE OR on <em>a</em>, <em>b</em>, etc., and produces
the result. A logical XOR can be performed if all the arguments are either
0 or 1.</dd>
</dl>
</div>
<div class="section" id="appendix-b-paste-operator-examples">
<h2><a class="toc-backref" href="#id34">1.11&nbsp;&nbsp;&nbsp;Appendix B: Paste Operator Examples</a><a class="headerlink" href="#appendix-b-paste-operator-examples" title="Permalink to this headline">¶</a></h2>
<p>Here is an example illustrating the use of the paste operator in record names.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>defvar suffix = &quot;_suffstring&quot;;
defvar some_ints = [0, 1, 2, 3];

def name # suffix {
}

foreach i = [1, 2] in {
def rec # i {
}
}
</pre></div>
</div>
<p>The first <code class="docutils literal notranslate"><span class="pre">def</span></code> does not use the value of the <code class="docutils literal notranslate"><span class="pre">suffix</span></code> variable. The
second def does use the value of the <code class="docutils literal notranslate"><span class="pre">i</span></code> iterator variable, because it is not a
global name. The following records are produced.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def namesuffix {
}
def rec1 {
}
def rec2 {
}
</pre></div>
</div>
<p>Here is a second example illustrating the paste operator in field value expressions.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def test {
  string strings = suffix # suffix;
  list&lt;int&gt; integers = some_ints # [4, 5, 6];
}
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">strings</span></code> field expression uses <code class="docutils literal notranslate"><span class="pre">suffix</span></code> on both sides of the paste
operator. It is evaluated normally on the left hand side, but taken verbatim
on the right hand side. The <code class="docutils literal notranslate"><span class="pre">integers</span></code> field expression uses the value of
the <code class="docutils literal notranslate"><span class="pre">some_ints</span></code> variable and a literal list. The following record is
produced.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def test {
  string strings = &quot;_suffstringsuffix&quot;;
  list&lt;int&gt; ints = [0, 1, 2, 3, 4, 5, 6];
}
</pre></div>
</div>
</div>
<div class="section" id="appendix-c-sample-record">
<h2><a class="toc-backref" href="#id35">1.12&nbsp;&nbsp;&nbsp;Appendix C: Sample Record</a><a class="headerlink" href="#appendix-c-sample-record" title="Permalink to this headline">¶</a></h2>
<p>One target machine supported by LLVM is the Intel x86. The following output
from TableGen shows the record that is created to represent the 32-bit
register-to-register ADD instruction.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>def ADD32rr { // InstructionEncoding Instruction X86Inst I ITy Sched BinOpRR BinOpRR_RF
  int Size = 0;
  string DecoderNamespace = &quot;&quot;;
  list&lt;Predicate&gt; Predicates = [];
  string DecoderMethod = &quot;&quot;;
  bit hasCompleteDecoder = 1;
  string Namespace = &quot;X86&quot;;
  dag OutOperandList = (outs GR32:$dst);
  dag InOperandList = (ins GR32:$src1, GR32:$src2);
  string AsmString = &quot;add{l}  {$src2, $src1|$src1, $src2}&quot;;
  EncodingByHwMode EncodingInfos = ?;
  list&lt;dag&gt; Pattern = [(set GR32:$dst, EFLAGS, (X86add_flag GR32:$src1, GR32:$src2))];
  list&lt;Register&gt; Uses = [];
  list&lt;Register&gt; Defs = [EFLAGS];
  int CodeSize = 3;
  int AddedComplexity = 0;
  bit isPreISelOpcode = 0;
  bit isReturn = 0;
  bit isBranch = 0;
  bit isEHScopeReturn = 0;
  bit isIndirectBranch = 0;
  bit isCompare = 0;
  bit isMoveImm = 0;
  bit isMoveReg = 0;
  bit isBitcast = 0;
  bit isSelect = 0;
  bit isBarrier = 0;
  bit isCall = 0;
  bit isAdd = 0;
  bit isTrap = 0;
  bit canFoldAsLoad = 0;
  bit mayLoad = ?;
  bit mayStore = ?;
  bit mayRaiseFPException = 0;
  bit isConvertibleToThreeAddress = 1;
  bit isCommutable = 1;
  bit isTerminator = 0;
  bit isReMaterializable = 0;
  bit isPredicable = 0;
  bit isUnpredicable = 0;
  bit hasDelaySlot = 0;
  bit usesCustomInserter = 0;
  bit hasPostISelHook = 0;
  bit hasCtrlDep = 0;
  bit isNotDuplicable = 0;
  bit isConvergent = 0;
  bit isAuthenticated = 0;
  bit isAsCheapAsAMove = 0;
  bit hasExtraSrcRegAllocReq = 0;
  bit hasExtraDefRegAllocReq = 0;
  bit isRegSequence = 0;
  bit isPseudo = 0;
  bit isExtractSubreg = 0;
  bit isInsertSubreg = 0;
  bit variadicOpsAreDefs = 0;
  bit hasSideEffects = ?;
  bit isCodeGenOnly = 0;
  bit isAsmParserOnly = 0;
  bit hasNoSchedulingInfo = 0;
  InstrItinClass Itinerary = NoItinerary;
  list&lt;SchedReadWrite&gt; SchedRW = [WriteALU];
  string Constraints = &quot;$src1 = $dst&quot;;
  string DisableEncoding = &quot;&quot;;
  string PostEncoderMethod = &quot;&quot;;
  bits&lt;64&gt; TSFlags = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0 };
  string AsmMatchConverter = &quot;&quot;;
  string TwoOperandAliasConstraint = &quot;&quot;;
  string AsmVariantName = &quot;&quot;;
  bit UseNamedOperandTable = 0;
  bit FastISelShouldIgnore = 0;
  bits&lt;8&gt; Opcode = { 0, 0, 0, 0, 0, 0, 0, 1 };
  Format Form = MRMDestReg;
  bits&lt;7&gt; FormBits = { 0, 1, 0, 1, 0, 0, 0 };
  ImmType ImmT = NoImm;
  bit ForceDisassemble = 0;
  OperandSize OpSize = OpSize32;
  bits&lt;2&gt; OpSizeBits = { 1, 0 };
  AddressSize AdSize = AdSizeX;
  bits&lt;2&gt; AdSizeBits = { 0, 0 };
  Prefix OpPrefix = NoPrfx;
  bits&lt;3&gt; OpPrefixBits = { 0, 0, 0 };
  Map OpMap = OB;
  bits&lt;3&gt; OpMapBits = { 0, 0, 0 };
  bit hasREX_WPrefix = 0;
  FPFormat FPForm = NotFP;
  bit hasLockPrefix = 0;
  Domain ExeDomain = GenericDomain;
  bit hasREPPrefix = 0;
  Encoding OpEnc = EncNormal;
  bits&lt;2&gt; OpEncBits = { 0, 0 };
  bit HasVEX_W = 0;
  bit IgnoresVEX_W = 0;
  bit EVEX_W1_VEX_W0 = 0;
  bit hasVEX_4V = 0;
  bit hasVEX_L = 0;
  bit ignoresVEX_L = 0;
  bit hasEVEX_K = 0;
  bit hasEVEX_Z = 0;
  bit hasEVEX_L2 = 0;
  bit hasEVEX_B = 0;
  bits&lt;3&gt; CD8_Form = { 0, 0, 0 };
  int CD8_EltSize = 0;
  bit hasEVEX_RC = 0;
  bit hasNoTrackPrefix = 0;
  bits&lt;7&gt; VectSize = { 0, 0, 1, 0, 0, 0, 0 };
  bits&lt;7&gt; CD8_Scale = { 0, 0, 0, 0, 0, 0, 0 };
  string FoldGenRegForm = ?;
  string EVEX2VEXOverride = ?;
  bit isMemoryFoldable = 1;
  bit notEVEX2VEXConvertible = 0;
}
</pre></div>
</div>
<p>On the first line of the record, you can see that the <code class="docutils literal notranslate"><span class="pre">ADD32rr</span></code> record
inherited from eight classes. Although the inheritance hierarchy is complex,
using superclasses is much simpler than specifying the 109 individual fields for each
instruction.</p>
<p>Here is the code fragment used to define <code class="docutils literal notranslate"><span class="pre">ADD32rr</span></code> and multiple other
<code class="docutils literal notranslate"><span class="pre">ADD</span></code> instructions:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>defm ADD : ArithBinOp_RF&lt;0x00, 0x02, 0x04, &quot;add&quot;, MRM0r, MRM0m,
                         X86add_flag, add, 1, 1, 1&gt;;
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">defm</span></code> statement tells TableGen that <code class="docutils literal notranslate"><span class="pre">ArithBinOp_RF</span></code> is a
multiclass, which contains multiple concrete record definitions that inherit
from <code class="docutils literal notranslate"><span class="pre">BinOpRR_RF</span></code>. That class, in turn, inherits from <code class="docutils literal notranslate"><span class="pre">BinOpRR</span></code>, which
inherits from <code class="docutils literal notranslate"><span class="pre">ITy</span></code> and <code class="docutils literal notranslate"><span class="pre">Sched</span></code>, and so forth. The fields are inherited
from all the parent classes; for example, <code class="docutils literal notranslate"><span class="pre">IsIndirectBranch</span></code> is inherited
from the <code class="docutils literal notranslate"><span class="pre">Instruction</span></code> class.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../TableGenFundamentals.html" title="TableGen Fundamentals"
             >next</a> |</li>
        <li class="right" >
          <a href="BackGuide.html" title="1   TableGen Backend Developer’s Guide"
             >previous</a> |</li>
  <li><a href="https://llvm.org/">LLVM Home</a>&nbsp;|&nbsp;</li>
  <li><a href="../index.html">Documentation</a>&raquo;</li>

          <li class="nav-item nav-item-1"><a href="../UserGuides.html" >User Guides</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="index.html" >TableGen Overview</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2003-2020, LLVM Project.
      Last updated on 2020-11-04.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.4.
    </div>
  </body>
</html>